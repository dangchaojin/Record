https://blog.csdn.net/N1314N/article/details/94652368?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control


C11的特性（智能指针、anto等等）

1、智能指针:
auto_ptr, unique_ptr,shared_ptr, weak_ptr   后三是C++11支持，第一个已经被C++11弃用。
（auto_ptr的资源维护动作是以inline的方式来完成的，在编译时代码会被扩展开来，所以使用它并不会牺牲效率。缺点：auto_ptr对象不可作为STL容器的元素；auto_ptr缺少对动态配置而来的数组的支持，如果用它来管理这些数组，结果是可怕的、不可预期的）

智能指针是一个类，当超出了类的实例对象的作用域时，会自动调用对象的析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。

shared_ptr,它采用引用计数的方法，记录当前内存资源被多少个智能指针引用。该引用计数的内存在堆上分配。当新增一个时引用计数加1，当过期时引用计数减一。只有引用计数为0时，智能指针才会自动释放引用的内存资源。
	use_count 返回引用计数的个数
	unique 返回是否是独占所有权( use_count 为 1)
	swap 交换两个 shared_ptr 对象(即交换所拥有的对象)
	reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少
	get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.

注意1：Smart_ptr<T>不同于T*
Smart_ptr<T>的真实身份其实是一个对象，一个管理动态配置对象的对象，而T*是指向T类型对象的一个指针，所以不能盲目地将一个T*和一个智能指针类型Smart_ptr<T>相互转换。
在创建一个智能指针的时候需要明确Smart_ptr<T> tPtr<new T>等。禁止将T*赋值给一个智能指针。不能采用tPtr = NULL的方式将tPtr置空，应该使用智能指针类的成员函数。


注意2：使用std::move
不论是shared_ptr还是unique_ptr，使用std::move转移之后，所管理的指针是空指针。


注意3：unique_ptr的release()与reset()区别、使用
在unique_ptr对象上调用release()将释放其关联的原始指针的所有权，并返回原始指针。这里是释放所有权，并没有delete原始指针，reset()会delete原始指针？？？？？？


注意4：shared_ptr对象指向数组
std::shared_ptr<int> p3(new int[12])
像这样申请的数组，应该调用delete[]释放内存，而shared_ptr析构函数中默认delete并不能满足需求。需要给shared_ptr添加自定义删除器
在上面在这种情况下，我们可以将回调函数传递给shared_ptr的构造函数，该构造函数将从其析构函数中调用以进行删除，即
void deleter(Sample *x)    //自定义删除器
{
	std::cout << "delete function called\n";
	delete[] x;
}
// 构造函数传递自定义删除器指针
std::shared_ptr<Sample> p3(new Sample[12], deleter);


注意5：不要使用同一个原始指针构造shared_ptr
创建多个shared_ptr的正常方法是使用一个已存在的shared_ptr进行创建，而不是使用同一个原始指针进行创建
int *num = new int(23);
std::shared_ptr<int> p1(num);
std::shared_ptr<int> p2(p1);   // 正确
std::shared_ptr<int> p3(num);  // 异常

std::cout << "p1 Reference = " << p1.use_count() << std::endl;   // 输出 2
std::cout << "p2 Reference = " << p2.use_count() << std::endl;   // 输出 2
std::cout << "p3 Reference = " << p3.use_count() << std::endl;   // 输出 1
假如使用原始指针num创建了p1，又同样方法创建了p3，当p1超出作用域时会调用delete释放num内存，此时num成了悬空指针，当p3超出作用域再次delete的时候就可能会出错。


注意5：不要用栈中的指针构造 shared_ptr 对象
shared_ptr 默认的构造函数中使用的是delete来删除关联的指针，所以构造的时候也必须使用new出来的堆空间的指针。
int x = 12;
std::shared_ptr<int> ptr(&x);   // 异常
当 shared_ptr 对象超出作用域调用析构函数delete 指针&x时会出错。



2、std::move
将一个左值强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义。从实现上讲，std::move基本等同于一个类型转换：static_cast<T&&>(lvalue);

注意1: C++ 标准库使用比如vector::push_back 等这类函数时,会对参数的对象进行复制,连数据也会复制.这就会造成对象内存的额外创建, 本来原意是想把参数push_back进去就行了,通过std::move，可以避免不必要的拷贝操作。
注意2: std::move是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存的搬迁或者内存拷贝所以可以提高利用效率,改善性能。
注意3: 对指针类型的标准库对象并不需要这么做。
注意4: 原value值被move之后值被转移，比如string被转移之后为空字符串，智能指针被转移之后所管理的也是空指针。



3、原生字符串字面值
C++11中原生字符串的声明相当简单，只需在字符串前加入前缀，即字母R，并在引号中使用括号左右标识，就可以声明该字符串字面量为原生字符串了。
例：cout << R"(hello, \n world)" << endl;


4、用户定义字面量
	 size_t operator"" _len(char const * str, size_t size){  return size;  }
long double operator"" _mm(long double x) { return x / 1000; }

5、


6、


7、

8、

9、


10、

11、

12、

13、

14、

15、

16、

17、

18、

19、
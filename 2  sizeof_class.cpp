/* 一个Class对象占用内存空间为: 非静态成员变量总和 + 数据对齐处理 + 虚函数
也就是说静态成员数据不做考虑。
所谓成员函数只是在名义上是类里的。其实成员函数的大小不在类的对象里面，同一个类的多个对象共享函数代码。

而析构函数，跟构造函数这些成员函数，是跟sizeof无关的，也不难理解因为我们的sizeof是针对实例，
而普通成员函数，是针对类体的，一个类的成员函数，多个实例也共用相同的函数指针，所以自然不能归为实例的大小。

而我们访问类的成员函数是通过类里面的一个指针实现，而这个指针指向的是一个table，table里面记录的各个成员函数的地址。
所以我们访问成员函数是间接获得地址的，这样也就增加了一定的时间开销，所以提倡把一些简短的，调用频率高的函数声明为inline形式（内联函数）。*/

#include <iostream>
using namespace std;

class A {};   //c++要求每个实例在内存中都有独一无二的地址!!!!!!!!
              //空类也会被实例化，所以编译器会给空类隐含的添加一个字节，这样空类实例化之后就有了独一无二的地址了。
              //所以空类的sizeof为1。

class B
{
public:
	B(){}
	virtual ~B(){}       //每个实例都有虚函数表
		                 //C++ 类中有虚函数的时候有一个指向虚函数的指针（vptr），在32位系统分配指针大小为4字节。
		                 //无论多少个虚函数，只有这一个指针，4字节。
		                 //注意一般的函数是没有这个指针的，而且也不占类的内存。

	void aa(){}          //普通成员函数，为各实例公有，不归入sizeof统计

	virtual void B1(){}     //虚函数记入sizeof统计，多个虚函数共用一个

private:
	char a;            //占4个字节（对齐的问题） int占4字节，注意这点和struct的对齐原则很像!! char占一字节，补齐3字节
	char *p;           //占4个字节（4字节指针）
	int b;             //占4个字节
	static int d;      //非实例独占
};

class C : public B
{
public:
	C(){}
	~C(){}
	virtual void test() {}
private:                        //子类的大小是本身成员变量的大小加上父类的大小。
	int c1;                     //其中有一部分是虚拟函数表的原因，一定要知道父类子类共享一个虚函数指针
};

class AA1 {};
class BB1
{
	virtual void fun();
};

class D : public AA1, public BB1 {};    //为了提高实例在内存中的存取效率．类的大小往往被调整到系统的整数倍．
                                        //并采取就近的法则，里哪个最近的倍数，就是该类的大小

int main()
{
	cout << "class A: " << sizeof(A) << endl;
	cout << "class B: " << sizeof(B) << endl;
	cout << "class C: " << sizeof(C) << endl;
	cout << "class D: " << sizeof(D) << endl;
	return 0;
}


/*总结:
空的类是会占用内存空间的，而且大小是1，原因是C++要求每个实例在内存中都有独一无二的地址。

（一）类内部的成员变量：
	1、普通的变量：是要占用内存的，但是要注意对齐原则（这点和struct类型很相似）。
	2、static修饰的静态变量：不占用内容，原因是编译器将其放在全局变量区。
 

（二）类内部的成员函数：
	1、普通函数：不占用内存。
	2、虚函数：要占用4个字节，用来指定虚函数的虚拟函数表的入口地址。所以一个类的虚函数所占用的地址是不变的，和虚函数的个数是没有关系
*/
1、c++三大特性，分别作用；三种继承的特点；
继承：一个对象获得另一个对象的属性和方法        作用：减少重复的代码，继承是多态的前提。

编译器总是在调用派生类构造函数之前调用基类构造函数。这个顺序在派生类对象销毁时就刚好反过来，即派生类中的析构函数在基类的析构函数之前调用。
构造函数：缺省构造函数时，系统将自动调用该缺省构造函数初始化对象，缺省构造函数会将所有数据成员都初始化为零或空
析构函数：析构函数没有参数，也没有返回值。不能重载，也就是说，一个类中只可能定义一个析构函数。如果一个类中没有定义析构函数，系统也会自动生成一个默认的析构函数，为空函数，什么都不做
                调用条件：a.在函数体内定义的对象，当函数执行结束时，该对象所在类的析构函数会被自动调用；  b.用new运算符动态构建的对象，在使用delete运算符释放它时。

封装：把客观事物封装成抽象的类，隐藏对象的属性和实现细节，仅仅对外提供接口和方法，类可以把自己的数据和方法只让可信的类或者对象操作
    隔离变化，便于使用，提高重用性，提高安全性

多态：向不同对象发生同一个消息，不同的对象在接收时会产生不同的行为(即方法)，分为动多态(运行期多态) 和 静多态(编译期多态)，而静多态主要通过模板、函数重载和运算符重载、宏多态来实现。动多态在C++中是通过虚函数实现的，即在基类中存在一些接口（一般为纯虚函数），子类必须重载这些接口。这样通过使用基类的指针或者引用指向子类的对象，就可以实现调用子类对应的函数的功能。动多态的函数调用机制是执行期才能进行确定，所以它是动态的。
    大大提高了代码的可复用性，提高了了代码的可维护性，可扩充性；
	
封装可以隐藏实现细节，使得代码模块化，继承可以扩展已存在的模块，它们目的都是为了：代码重用。而多态是为了实现另一个目的：接口重用。


2、虚析构函数、虚函数、虚继承、虚基类    什么函数不可以被定义为虚函数（详解见文末）
虚析构函数：被virtual关键字修饰的析构函数。    为了解决用一个基类的指针删除一个派生类的对象时，派生类的析构函数会被调用。
虚函数：被virtual关键字修饰的成员函数。    实现多态性，多态性是将接口与实现进行分离
虚继承：继承方式前面加上virtual关键字。    为了解决多继承时的命名冲突和冗余数据问题，使得在派生类中只保留一份间接基类的成员
虚基类：虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类

一个类有一个或者一个以上的虚函数，则该类有且只有一张虚函数表，每个类都只有一个虚函数表，该类的所有对象都共享这张虚函数表

不可以被定义为虚函数的：普通函数（非成员函数）、静态成员函数、内联成员函数、构造函数、友元函数


3、重载、重写（覆盖）、隐藏、
重载：同一作用域内被声明的几个具有不同参数列表（参数类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型
重写（覆盖）：在派生类中被重新定义的虚函数。（其函数名，参数列表，都必须同基类中被重写的函数一致）
隐藏（重定义）：是指派生类的函数屏蔽了与其同名的基类函数，注意只要同名函数并且基类没有virtual修饰，不管参数列表是否相同，基类函数都会被隐藏。


5、new/delete和malloc/free区别联系
a.最大区别是对对象的理解：malloc只是单纯的分配空间，而不是想创建一个对象，new会先分配空间然后调用构造函数来初始化空间变成对象。delete会先调用析构函数再释放空间。   本质：new\delete玩的是对象，而malloc\free仅仅是内存空间而已
b.malloc/free为C的标准库函数，new/delete则为C++的操作运算符，调用的分别为赋值运算符重载operator new()和operator delete()；
c.malloc返回类型为void*，必须强制类型转换对应类型指针，new则直接返回对应类型指针；
d.malloc开辟的内存永远是通过free来释放的；而new单个元素内存，用的是delete，如果new[]数组，用的是delete[]来释放内存的。
e.malloc开辟内存时返回内存地址要检查判空，因为若它可能开辟失败会返回NULL；new则不用判断，因为内存分配失败时，它会抛出异常bac_alloc,可以使用异常机制；
f.malloc开辟空间类型大小需手动计算，new是由编译器自己计算；
g.new/delete底层是基于malloc/free来实现的；
h.new/delete是操作符，它调用operator new / operator delete,它们可以被重载，在标准库里它有8个重载版本；而malloc/free不可以重载；
i.对于malloc分配内存后，若在使用过程中内存分配不够或太多，这时可以使用realloc函数对其进行扩充或缩小，但是new分配好的内存不能这样被直观简单的改变；
j.malloc是在堆上分配内存的，new相当于也是在堆上开辟内存的


6、内存中的几个区域
a、栈区（stack）：由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
b、堆区（heap）：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。
c、全局/静态区(static）：全局变量和静态变量的存储是 放在一块的，在程序编译时分配
d、文字常量区：存放常量字符串
e、程序代码区：存放函数体(类的成员函数、全局函数)的二进制代码


7、拷贝构造函数   一定要引用么？
拷贝构造函数是一种特殊的构造函数，作用就是用来复制对象，(编译器调用)用同一类中之前创建的对象来创建、初始化新对象。

拷贝构造函数形参必须是引用，但并不限制为const。必须是引用传递，不能是值传递原因：为了防止递归引用。
当一个对象需要以值方式传递时，编译器会生成代码调用它的拷贝构造函数以生成一个复本对象。如果类A的拷贝构造函数是以值方式传递一个类A对象作为参数的话，当需要调用类A的拷贝构造函数时，需要以值方式传进一个A的对象作为实参；

通常用于：a、通过使用另一个同类型的对象来初始化新创建的对象。  b、复制对象把它作为参数传递给函数。  c、复制对象，并从函数返回这个对象。

如果在类中没有定义拷贝构造函数，编译器会自动生成一个默认的拷贝函数(浅拷贝)，来进行对象之间非static成员的位拷贝。如果类数据成员带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。
当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致重复释放一块内存两次。
深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。



8、指针与引用区别与联系      以及使用场景
1）相同点： 都是地址的概念；
指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名。
2）不同点：
指针是一个实体，需要分配内存空间。引用只是另一个变量的别名，不需要分配内存空间。
引用只能在定义时被初始化一次，之后不可变；指针可变；引用“从一而终”，指针可以“见异思迁”；
引用没有const，指针有const，const的指针不可变；（也就是说，没有int& const a这种形式，而const int& a这种形式是有的。前者指引用本身即别名不可以改变，这是一定的，因此不需要这种形式，后者指引用所指的值不可以改变）
引用不能为空，指针可以为空；
“sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；
指针和引用的自增(++)运算意义不一样（指针是指向下一个空间，引用时引用的变量值加1）；
不存在指向空值的引用这个事实，意味着使用引用的代码效率比使用指针的要高。因为在使用引用之前不需要测试它的合法性。相反，指针则应该总是要测试防止为空。
引用访问一个变量是直接访问，而指针访问一个变量是间接访问（只是访问，跟寻址方式不一样，注意下）
理论上，对于指针的级数没有限制，但是引用只能是一级。如下：
  int** p1;         // 合法。指向指针的指针
  int*& p2;        // 合法。指向指针的引用
  int&* p3;        // 非法。指向引用的指针是非法的
  int&& p4;       // 非法。指向引用的引用是非法的

常用于函数的参数传递和返回值
使用引用参数的主要原因有两个：  1）程序员能够修改调用函数中的数据对象。  2）通过传递引用而不是整个数据对象，可以提高程序的运行速度。
对于那些函数，它们只使用传递过来的值，而不对值进行修改。
        （1）如果数据对象很小，如内置数据类型或小型结构，使用按值传递。
        （2）如果数据对象是数组，则使用指向const的指针。
        （3）如果数据对象是较大的结构，则使用const指针或者const引用，以提高程序的效率。
        （4）如果数据对象是类对象，则使用const引用。因此，传递类对象参数的标准方式是按引用传递。
对于那些函数，它们需要修改传递过来的值。
       （1）如果数据对象是内置数据类型，则使用指针。
       （2）如果数据对象师叔祖，则只能使用指针。
       （3）如果数据对象是结构。则使用指针或者引用。
       （4）如果数据对象是类对象，则使用引用。

9、指针传递、值传递、引用传递             指针传递与引用传递细节可参考  文末指针和引用讲解
值传递：形参是实参的拷贝，把实际参数的值传递给对应的形式参数，改变形参的值并不会影响外部实参的值。从被调用函数的角度来说，值传递是单向的（实参->形参），参数的值只能传入，不能传出。
void swap(int a, int b)  {     int temp;  temp=a;  a=b;  b=temp;    }

指针传递：形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。指针传递参数本质上是值传递的方式，它所传递的是一个地址值。
void swap(int *a, int *b)  {    int temp;   temp=*a;  *a=*b;  *b=temp;    }

引用传递：形参相当于是实参的“别名”，对形参的操作其实就是对实参的操作，在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。
void swap(int &a, int &b)  {    int temp;  temp=a;  a=b;  b=temp;    }

值传递不如地址传递高效，因为值传递先从实参的地址中取出值，再赋值给形参代入函数计算；而指针则把形参的地址直接指向实参地址，使用时直接取出数据，效率提高，特别在频繁赋值等情况下


10、static、const、volatile关键字的作用及应用范围
修饰函数的局部变量      特点：有默认值0，只执行一次，运行一开始就开辟了内存，内存放在全局
修饰全局函数和全局变量      特点：只能在本源文件使用
修饰类里面的成员变量      不进入类的大小计算，不依赖于类对象的存在而存在（可直接调用，要进行外置声明）
修饰类的成员函数      f():括号里无this指针，只能调用他的本类静态函数和他的静态变量，即是用static修饰过的不依赖于类对象的存在而存在（可不进行外置声明，直接调用）

const 在C++中是用来修饰内置类型变量，自定义对象，成员函数，返回值，函数参数。
const修饰普通类型的变量： const int  a = 7; a被定义为一个常量，并且可以将a赋值给b，但是不能给a再次赋值。
const 修饰指针变量：A:const 修饰指针指向的内容，则内容为不可变量。  B:const 修饰指针，则指针为不可变量。  C:const 修饰指针和指针指向的内容，则指针和指针指向的内容都为不可变量。  （左定值，右定向，const修饰不变量。）
const in function参数传递：A：值传递的const修饰传递，一般这种情况不需要const修饰，因为函数会自动产生临时变量复制实参值。B：当const参数为指针时，可以防止指针被意外篡改。C：自定义类型的参数传递，需要临时对象复制参数，对于临时对象的构造，需要调用构造函数，比较浪费时间，因此我们采取const外加引用传递的方法。
const修饰函数的返回值：const 修饰自定义类型的作为返回值，此时返回的值不能作为左值使用，既不能被赋值，也不能被修改。
const修饰类成员函数：const 修饰类成员函数，其目的是防止成员函数修改被调用对象的值，如果我们不想修改一个调用对象的值，所有的成员函数都应当声明为const成员函数。注意：const关键字不能与static关键字同时使用，因为static关键字修饰静态成员函数，静态成员函数不含有this指针，即不能实例化，const成员函数必须具体到某一实例。尽量按照要求将所有的不需要改变对象内容的函数都作为const成员函数。如果有个成员函数想修改对象中的某一个成员怎么办？这时我们可以使用mutable关键字修饰这个成员，mutable的意思也是易变的，容易改变的意思，被mutable关键字修饰的成员可以处于不断变化中。

volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。
遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问

11、声明和定义
为变量分配地址和存储空间的称为定义，不分配地址的称为声明。一个变量可以在多个地方声明，
但是只在一个地方定义。加入extern修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。说明：很多时候一个变量，只是声明不分配内存空间，直到具体使用时才初始化，分配内存空间，如外部变量。


12、sizeof 和 strlen 的区别
sizeof 是一个操作符，strlen 是库函数
sizeof 的参数可以是数据的类型，也可以是变量，而 strlen 只能以结尾为‘\0‘的字符串作参数。
并且 sizeof 计算的是数据类型占内存的大小，而 strlen 计算的是字符串实际的长度。
编译器在编译时就计算出了 sizeof 的结果。而 strlen 函数必须在运行时才能计算出来。


13、常量指针、指针常量
常量指针：指向常量的指针，指针指向的是常量，即它不能指向变量，它指向的内容不能被改变，不能通过指针来修改它指向的内容，但是指针自身不是常量，它自身的值可以改变，从而可以指向另一个常量。
指针常量：指针本身是常量。它指向的地址是不可改变的，但地址里的内容可以通过指针改变。它指向的地址将伴其一生，直到生命周期结束。有一点需要注意的是，指针常量在定义时必须同时赋初值。
常量指针使用：如 int b, c;  int const *a;
a = &b;  a = &c;  都可以，唯独它指向的内容不能被修改。如：*a=20;这是违法的！错误！

指针常量使用：如 int a ,b;  int * const p = &a;  表示p是一个常量指针它指向变量a的内存。指针常量不能再用p指向其他变量，如 p = &b; 错误！可以修改指向内存的值，如:* p = 20; 指针常量声明的时候必须像上式那样赋初值。
指针常量也不能释放,用p指向NULL，即 p = NULL; 会在编译时报错。

看const关键字，他后面的不可修改，如int * const a = &b; 后面是a,则说明a不能修改！
常量指针：int const *n; 等价于 const int *n;


14、c++四种强制类型转化
static_cast、const_cast、reinterpret_cast和dynamic_cast         新类型的强制转换可以提供更好的控制强制转换过程。
static_cast用于将一种数据类型强制转换为另一种数据类型。
（1）用于类层次结构中基类和派生类之间指针或引用的转换
      进行上行转换（把派生类的指针或引用转换成基类表示）是安全的。进行下行转换（把基类的指针或引用转换为派生类表示），由于没有动态类型检查，所以是不安全的
（2）用于基本数据类型之间的转换，如把int转换成char。这种转换的安全也要开发人员来保证
（3）把空指针转换成目标类型的空指针
（4）把任何类型的表达式转换为void类型
注意：static_cast不能转换掉expression的const、volitale或者__unaligned属性。

const_cast用于强制去掉不能被修改的常数特性，但需要特别注意的是const_cast不是用于去除变量的常量性，而是去除指向常数对象的指针或引用的常量性，其去除常量性的对象必须为指针或引用。
该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。
    常量指针被转化成非常量指针，并且仍然指向原来的对象；
    常量引用被转换成非常量引用，并且仍然指向原来的对象；
    常量对象被转换成非常量对象。

在C++语言中，reinterpret_cast主要有三种强制转换用途：改变指针或引用的类型、将指针或引用转换为一个足够长度的整形、将整型转换为指针或引用类型。
用法：reinterpret_cast<type_id> (expression)    type-id必须是一个指针、引用、算术类型、函数指针或者成员指针。
它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）。在使用reinterpret_cast强制转换过程仅仅只是比特位的拷贝，因此在使用过程中需要特别谨慎！

dynamic_cast<type_id> (expression)
（1）其他三种都是编译时完成的，dynamic_cast是运行时处理的，运行时要进行类型检查。
（2）不能用于内置的基本数据类型的强制转换。
（3）dynamic_cast转换如果成功的话返回的是指向类的指针或引用，转换失败的话则会返回NULL。
（4）使用dynamic_cast进行转换的，基类中一定要有虚函数，否则编译不通过。基类中需要检测有虚函数的原因：类中存在虚函数，就说明它有想要让基类指针或引用指向派生类对象的情况，此时转换才有意义。这是由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表中，只有定义了虚函数的类才有虚函数表。
（5）在类的转换时，在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的。在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。向上转换，即为子类指针指向父类指针（一般不会出问题）；向下转换，即将父类指针转化子类指针。向下转换的成功与否还与将要转换的类型有关，即要转换的指针指向的对象的实际类型与转换以后的对象类型一定要相同，否则转换失败。在C++中，编译期的类型转换有可能会在运行时出现错误，特别是涉及到类对象的指针或引用操作时，更容易产生错误。Dynamic_cast操作符则可以在运行期对可能产生问题的类型转换进行测试。


15、c++ 八种基本数据类型
整型：
byte：-2^7 ~ 2^7-1，即-128 ~ 127。1字节。末尾加B
short：-2^15 ~ 2^15-1，即-32768 ~ 32767。2字节。末尾加S
有符号int：-2^31 ~ 2^31-1，即-2147483648 ~ 2147483647。4字节。
无符号int：0~2^32-1。
long：-2^63 ~ 2^63-1，即-9223372036854774808 ~ 9223372036854774807。4字节。末尾加L。（也可以不加L）
浮点型：
float：4字节。末尾加F。（也可以不加F）
double：8字节。
字符型：
char：1字节。
布尔型：
boolean：1字节。boolean类型与其他基本类型不能进行类型的转换(既不能进行自动类型的提升，也不能强制类型转换)，否则将编译出错。

两个数值进行二元操作时，会有如下的转换操作：如果两个操作数其中有一个是double类型，另一个操作就会转换为double类型。如果其中一个操作数是float类型，另一个将会转换为float类型。如果其中一个操作数是long类型，另一个会转换为long类型。否则，两个操作数都转换为int类型。
当对小于int的数据类型（byte, char, short）进行运算时，首先会把这些类型的变量值强制转为int类型进行计算，最后会得到int类型的值。因此，如果把2个short类型的值相加，最后得到的结果是int类型，如果需要得到short类型的结果，就必须显示地运算结果转为short类型。


15、类class与结构体struct   结构体struct跟联合体union
类中定义的继承和成员变量、成员函数默认都是private属性的，结构体中定义的继承和成员变量、成员函数默认都是public属性的。

struct各成员各自拥有自己的内存，各自使用互不干涉，同时存在的，遵循内存对齐原则。一个struct变量的总长度等于所有成员的长度之和。
union各成员共用一块内存空间，并且同时只有一个成员可以得到这块内存的使用权(对该内存的读写)，各变量共用一个内存首地址。因而，联合体比结构体更节约内存。一个union变量的总长度至少能容纳最大的成员变量，而且要满足是所有成员变量类型大小的整数倍。
对于Union的不同成员赋值，将会对其他成员重写，原来成员的值就不存在了
还有关于struct内存存放顺序的问题以及两者内存对齐方式不同的见下面详解


16、内联函数   使用场景
不是在调用时发生控制转移，而是在编译时将函数体嵌入在每一个调用处，适用于功能简单，规模较小又使用频繁的函数。递归函数无法内联处理，内联函数不能有循环体，switch语句，不能进行异常接口声明。
内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。

内联函数和宏的区别在于，宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的。而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。你可以象调用函数一样来调用内联函数，而不必担心会产生于处理宏的一些问题。内联函数与带参数的宏定义进行下比较，它们的代码效率是一样，但是内联欢函数要优于宏定义，因为内联函数遵循的类型和作用域规则，它与一般函数更相近，在一些编译器中，一旦关联上内联扩展，将与一般函数一样进行调用，比较方便。 
另外，宏定义在使用时只是简单的文本替换，并没有做严格的参数检查，也就不能享受C++编译器严格类型检查的好处，一些在宏中的编译错误很难发现，另外它的返回值也不能被强制转换为可转换的合适的类型，这样，它的使用就存在着一系列的隐患和局限性。
内联函数不能包括复杂的控制语句，如循环语句和switch语句；
内联函数不能包括复杂的控制语句，如循环语句和switch语句；
只将规模很小（一般5个语句一下）而使用频繁的函数声明为内联函数。在函数规模很小的情况下，函数调用的时间开销可能相当于甚至超过执行函数本身的时间，把它定义为内联函数，可大大减少程序运行时间。


17、Linux /proc/$pid部分内容详解
proc/[pid]/cmdline是一个只读文件，包含进程的完整命令行信息。如果这个进程是zombie进程，则这个文件没有任何内容。
/proc/[pid]/comm包含进程的命令名。
/proc/[pid]/environ显示进程的环境变量。
/proc/[pid]/fd是一个目录，包含进程打开文件的情况。
/proc/[pid]/latency显示哪些代码造成的延时比较大。
/proc/[pid]/maps显示进程的内存区域映射信息。


18、指针函数、函数指针


19、


20、进程和线程的区别与联系？进程间通信方式？
进程（Process） 是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。 在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。
线程（thread） 是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。

a）进程是资源分配的最小单位，线程是程序执行的最小单位（资源调度的最小单位）。
b）进程有自己的独立的地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程小很多，同时创建一个线程的开销也远比进程要小很多。
c）线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式(IPC)进行。
d）但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另一个进程造成影响，因为进程有自己独立的地址空间。

进程间通讯方式：管道、消息队列、信号量、共享内存区、套接字
管道：速度慢，容量有限，只有父子进程能通讯
消息队列：容易受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题
信号量：不能传递复杂消息，只能用来同步
共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存
套接字：可用于不同机器间的进程通信


19、tcp、udp区别联系   三次握手细节及原因   四次**
a、TCP面向连接(如打电话要先拨号建立连接)；UDP是无连接的，即发送数据之前不需要建立连接。
b、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。TCP通过校验和checksum，重传控制，序号标识，滑动窗口机制、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。
c、UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。
d、每一条TCP连接只能是点到点的；UDP支持一对一、一对多、多对一和多对多的交互通信。
e、TCP对系统资源要求较多，UDP对系统资源要求较少。

三次握手                       SYN：同步序列编号（Synchronize Sequence Numbers）。
第一次握手：建立连接时，客户端发送syn包（seq=j）到服务器，并进入SYN_SENT状态，等待服务器确认；
第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（seq=k），即SYN+ACK包，此时服务器进入SYN_RECV状态。
第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。


网速的提升给UDP的稳定性提供可靠网络保障，丢包率很低，如果使用应用层重传，能够确保传输的可靠性。
TCP为了实现网络通信的可靠性，使用了复杂的拥塞控制算法，建立了繁琐的握手过程，由于TCP内置的系统协议栈中，极难对其进行改进。


21、设计模式    常用的
工厂模式、策略模式、适配器模式、单例模式、原型模式、模板模式、建造者模式、外观模式、组合模式、代理模式、享元模式、桥接模式、装饰模式、备忘录模式、中介者模式、职责链模式、观察者模式







22、程序运行得比较慢，有什么优化方案
a）编码技巧，汇编，编译器等也是一方面，但是首先要逻辑优化
b）在问如何提高运行速度前 你应该先去了解你的程序慢在哪儿。现成的工具有很多
    比如可以通过火焰图快速的定位程序到底慢在哪里 然后对症下药。
    了解自己的代码做了什么东西，建议用辅助调试工具来检测profile，可以关注下是否有冗余的计算，I/O，锁
c）了解对应的执行环境，硬件差异，系统差异，比如说CPU的特殊指令，GPU与CPU，SSD的写放大，如IOS里面调动态库的执行速度会比同一个静态库的慢些，由于中途多做了一次寻址；SSD上按字节来写可能比按最小块写要慢
d）如果性能相差很多，很可能问题出现在算法上面。就像冒泡排序和快速排序的差距。了解是否有更加合适的算法，一般来说拿空间换时间，或者拿准确度来换时间


、学到了啥？  下一步规划

、项目的并发量级      有没有性能问题 诊断和优化的生产经验    项目的真实调优过程

、一些编程小技巧
a、能用引用的地方尽量用引用，这比指针高效，因为引用无需检验
b、
c、


、this指针的作用

、讲一下堆与找的区别与联系（内存分配Heap和stack的区别）
为啥malloc申请到的堆的空间是连续的？   是因为前面有个空间存储了长度？


、加载动态库的几种方式？运行时调用的几种方式？


、七层网络模型、5层网络模型、以及分别对应的协议

、为啥从main开始？

、epoll和select的区别是什么？epoll高效率的原因是什么？（分别适用在什么应用场景）

、野指针   内存泄漏    指针悬挂      （分别是什么？代表什么？怎么造成？怎么避免解决？）
（多个指针指向一块内存，free掉一个指针之后，别的指针就成了野指针？）


、查bug思路

、linux常用命令


、算法题：

mencpy函数实现
void * my_mencpy(void *dst, void *src, unsigned count)
{
	if(dst == NULL || src == NULL) return NULL;
	char *pdst = (char*)dst;
	char *psrc = (char*)src;
	while(count--)
	{
		*pdst++ = *psrc++;
	}
	return dst;
}


strcpy函数实现
char *my_strcpy(char* dst, const char* src)
{
	if(dst == NULL || src == NULL) return NULL;
	char* temp = dst;
	while( (*dst++ = *src++) != '\0' ) ;
	return temp;
}


冒泡排序、快速排序、二分查找
设计栈  入栈  出栈  找最小元素
设计string  成员
编写简单的回显函数
创建一个单向链表，插入十个数据
创建一个二叉树，插入是个数据
通用二元一次方程函数
图像边缘检测原理
STL里面vector、list、map、set底层数据结构   以及应用场景
查询多，插入少  用什么？为什么？








整理下  a++，++a  ???
#include <stdio.h>
#include <iostream>
using namespace std;
#define MU(a) ((a)*(a)*(a))
int main(int argc,char *argv[])
{
	int i = 10;
	/*int Sum = Add(i);
	printf("sUM1 = %d\n",Sum);
	int sum = MU(++i);
	printf("i = %d MU = %d\n",i,sum);*/

	printf("%d %d %d %d\n", ++i,i++,i++,i++);
	i = 10;
	//printf("%p %p %p\n", i++,++i,i);
	printf("%d\n",i);
	printf("%d %d %d %d\n", i,i,i++,i++);
	i = 10;
	printf("%d %d\n", i++,i++);
	i = 10;
	printf("%d %d\n", ++i,++i);
	i = 10;
	cout<<++i<<","<<i++<<endl;
	i = 2;
	printf("%d %d %d \n",i*=2,++i,i++);
	return 0;
}



*****************************************************************************************************************************************************************
****************************************************             以下是对上面知识点的扩展                 *******************************************************
*****************************************************************************************************************************************************************

static作用                   可参考：https://www.cnblogs.com/xuecl/p/12880968.html        https://www.cnblogs.com/songdanzju/p/7422380.html
1.先来介绍它的第一条也是最重要的一条：隐藏。（static函数，static变量均可）
当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性，其它的源文件也能访问。如果加了static，就会对其它源文件隐藏，在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。static可以用作函数和变量的前缀，对于函数来讲，static的作用仅限于隐藏.
warning：不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；

2.static的第二个作用是保持变量内容的持久。（static变量中的记忆功能和全局生存期）
存储在静态存储区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。
PS：如果作为static局部变量在函数内定义，它的生存期为整个源程序，但是其作用域仍与自动变量相同，只能在定义该变量的函数内使用该变量。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；
int fun(){           //此处需要注意作用域，如函数外定义了全局变量count，在函数内count仍是函数内的count
static int count = 10; //在第一次进入这个函数的时候，变量a被初始化为10！并接着自减1，以后每次进入该函数，a
return count--;}        //就不会被再次初始化了，仅进行自减1的操作；在static发明前，要达到同样的功能，则只能使用全局变量；
把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域， 限制了它的使用范围。

3.static的第三个作用是默认初始化为0（static变量）
其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。

最后对static的三条作用做一句话总结。首先static的最主要功能是隐藏，其次因为static变量存放在静态存储区，所以它具备持久性和默认值0. 

4.static的第四个作用：C++中的类成员声明static
在类中声明static变量或者函数时，初始化时使用作用域运算符来标明它所属类，因此，静态数据成员是类的成员，而不是对象的成员，这样就出现以下作用：
(1)类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致了它仅能访问类的静态数据和静态成员函数。      
(2)不能将静态成员函数定义为虚函数。      
(3)由于静态成员声明于类中，操作于其外，所以对其取地址操作，就多少有些特殊 ，变量地址是指向其数据类型的指针 ，函数地址类型是一个“nonmember函数指针”。
(4)由于静态成员函数没有this指针，所以就差不多等同于nonmember函数，结果就 产生了一个意想不到的好处：成为一个callback函数，使得我们得以将C++和C-based X W indow系统结合，同时也成功的应用于线程函数身上。 （这条没遇见过）  
(5)static并没有增加程序的时空开销，相反她还缩短了子类对父类静态成员的访问 时间，节省了子类的内存空间。      
(6)静态数据成员在<定义或说明>时前面加关键字static。      
(7)静态数据成员是静态存储的，所以必须对它进行初始化。（程序员手动初始化，否则编译时一般不会报错，但是在Link时会报错误） 
(8)静态成员初始化与一般数据成员初始化不同：初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆；初始化时不加该成员的访问权限控制符private，public等；初始化时使用作用域运算符来标明它所属类； 所以我们得出静态数据成员初始化的格式：<数据类型><类名>::<静态数据成员名>=<值>
(9)为了防止父类的影响，可以在子类定义一个与父类相同的静态变量，以屏蔽父类的影响。这里有一点需要注意：我们说静态成员为父类和子类共享，但我们有重复定义了静态成员，这会不会引起错误呢？不会，我们的编译器采用了一种绝妙的手法：name-mangling 用以生成唯一的标志。

静态成员变量，不属于对象，而属于类。不能在类的内部初始化，类中只能声明，定义需要在类外。类外定义时不用加static关键字，只需要表明类的作用域。
在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。所以调用不依赖对象，所以不能作为虚函数。对多个对象来说，静态数据成员只存储一处，供所有对象共用。



const、Volatile关键字的作用及应用范围             https://www.cnblogs.com/wshisuifeng/p/10873344.html
main(void)
{    const int  a = 7;
    int  *p = (int*)&a;
    *p = 8;
    cout<<a;
}
对于const变量a，我们取变量的地址并转换赋值给 指向int的指针，然后利用*p = 8;重新对变量a地址内的值赋值，然后输出查看a的值。从调试窗口看到a的值被改变为8，但是输出的结果仍然是7。
从结果中我们可以看到，编译器然后认为a的值为一开始定义的7，所以对const a的操作就会产生上面的情况。所以千万不要轻易对const变量设法赋值，这会产生意想不到的行为。
如果不想让编译器察觉到上面到对const的操作，我们可以定义时在const前面加上volatile关键字。Volatile关键字跟const对应相反，是易变的，容易改变的意思。所以不会被编译器优化，编译器也就不会改变对a变量的操作。








指针和引用
从概念上讲。指针从本质上讲就是存放变量地址的一个变量，在逻辑上是独立的，它可以被改变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变。
而引用是一个别名，它在逻辑上不是独立的，它的存在具有依附性，所以引用必须在一开始就被初始化，从而指向一个已经存在的对象，所以引用不能指向空值。而且其引用的对象在其整个生命周期中是不能被改变的（自始至终只能依附于同一个变量）。

在C++中，指针和引用经常用于函数的参数传递，然而，指针传递参数和引用传递参数是有本质上的不同的：
指针传递参数本质上是值传递的方式，它所传递的是一个地址值。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，即在栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。（这里是在说实参指针本身的地址值不会变）
而在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址（int &a的形式）。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。
引用传递和指针传递是不同的，虽然它们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。而对于指针传递的参数，如果改变被调函数中的指针地址，它将影响不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量，那就得使用指向指针的指针，或者指针引用。

从编译的角度来阐述它们之间的区别：程序在编译时分别将指针和引用添加到符号表上，符号表上记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值。符号表生成后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。




结构体跟联合体        参考：https://blog.csdn.net/firefly_2002/article/details/7954458?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param
union u
{
　double a;
　int b;
};
union u2
{
　char a[13];
　int b;
};
union u3
{
　char a[13];
　char b;
};

cout<<sizeof(u)<<endl; // 8
cout<<sizeof(u2)<<endl; // 16
cout<<sizeof(u3)<<endl; // 13
都知道union的大小取决于它所有的成员中，占用空间最大的一个成员的大小。所以对于u来说，大小就是最大的double类型成员a了，所以sizeof(u)=sizeof(double)=8。但是对于u2和u3，最大的空间都是char[13]类型的数组，为什么u3的大小是13，而u2是16呢？关键在于u2中的成员int b。由于int类型成员的存在，使u2的对齐方式变成4，也就是说，u2的大小必须在4的对界上，所以占用的空间变成了16（最接近13的对界）。
结论：复合数据类型，如union，struct，class的对齐方式为成员中对齐方式最大的成员的对齐方式。

顺便提一下CPU对界问题，32的C++采用8位对界来提高运行速度，所以编译器会尽量把数据放在它的对界上以提高内存命中率。对界是可以更改的，使用#pragma pack(x)宏可以改变编译器的对界方式，默认是8。C++固有类型的对界取编译器对界方式与自身大小中较小的一个。例如，指定编译器按2对界，int类型的大小是4，则int的对界为2和4中较小的2。在默认的对界方式下，因为几乎所有的数据类型都不大于默认的对界方式8（除了long double），所以所有的固有类型的对界方式可以认为就是类型自身的大小。更改一下上面的程序：
#pragma pack(2)
union u2
{
　char a[13];  int b;
};
union u3
{
　char a[13];  char b;
};
#pragma pack(8)

cout<<sizeof(u2)<<endl; // 14 由于手动更改对界方式为2，所以int的对界也变成了2，u2的对界取成员中最大的对界，也是2了，所以此时sizeof(u2)=14。
cout<<sizeof(u3)<<endl; // 13 ，char的对界为1
结论：C++固有类型的对界取编译器对界方式与自身大小中较小的一个。

struct的sizeof问题
因为对齐问题使结构体的sizeof变得比较复杂，看下面的例子：(默认对齐方式下)
struct s1
{
　char a;
　double b;
　int c;
　char d;
};
struct s2
{
　char a;
　char b;
　int c;
　double d;
};
cout<<sizeof(s1)<<sizeof(s2)<<endl; // 24 16
//如果去掉double b，就是以剩下的int为准，就是12  8

同样是两个char类型，一个int类型，一个double类型，但是因为对界问题，导致他们的大小不同。计算结构体大小可以采用元素摆放法，我举例子说明一下：首先，CPU判断结构体的对界，根据上一节的结论，s1和s2的对界都取最大的元素类型，也就是double类型的对界8。然后开始摆放每个元素。
对于s1，首先把a放到8的对界，假定是0，此时下一个空闲的地址是1，但是下一个元素d是double类型，要放到8的对界上，离1最接近的地址是8了，所以d被放在了8，此时下一个空闲地址变成了16，下一个元素c的对界是4，16可以满足，所以c放在了16，此时下一个空闲地址变成了20，下一个元素d需要对界1，也正好落在对界上，所以d放在了20，结构体在地址21处结束。由于s1的大小需要是8的倍数，所以21-23的空间被保留，s1的大小变成了24。
对于s2，首先把a放到8的对界，假定是0，此时下一个空闲地址是1，下一个元素的对界也是1，所以b摆放在1，下一个空闲地址变成了2；下一个元素c的对界是4，所以取离2最近的地址4摆放c，下一个空闲地址变成了8，下一个元素d的对界是8，所以d摆放在8，所有元素摆放完毕，结构体在15处结束，占用总空间为16，正好是8的倍数。

特例：
union{    int i;  char x[2];    }a;
void main()  {    a.x[0]=10;  a.x[1]=1;  printf("%d",a.i);    }
存储的时候是“低位在前”，a[0]是00001010，a[1]是00000001
输出的i是将二个字节作为一个整数看，即是x[1]x[0]也就是00000001 00001010      即 256+8+2=266。



new/delete和malloc/free区别联系
new[]/delete[]：在开辟大小会多开辟四个字节，用于存放对象的个数，在返回地址时则会向后偏移4个字节，而在delete时则会查看内存上对象个数，从而根据个数count确定调用几次析构函数，从而完全清理所有对象占用内存。
所以对于内置类型若new[]但用delete释放时，没有影响，但若是自定义类型如类时，若释放使用delete时，这时则会只调用一次析构函数，只析构了一个对象，剩下的对象都没有被清理。
参考：https://blog.csdn.net/weibo1230123/article/details/81980889                


构造函数与析构函数都是公有函数？因为不是公有函数类外访问不到！

拷贝构造函数参考：https://www.cnblogs.com/alantu2018/p/8459250.html
有拷贝构造函数前提：
void g_fun(CExample c)  {    cout<<"g_func"<<endl;    }
main()  {    CExample A(100);  g_fun(A);    }
调用g_fun()时，会产生以下几个重要步骤：
(1).A对象传入形参时，会先会产生一个临时变量，就叫C吧。
(2).然后调用拷贝构造函数把A的值给C。 整个这两个步骤有点像：CExample C(A);
(3).等g_fun()执行完后, 析构掉C对象。  



什么函数不可以被定义为虚函数详解：
虚函数通过继承方式来体现出多态作用，它必须是基类的非静态成员函数，其访问权限可以是protected或public，在基类的类定义中定义虚函数的一般形式是：
virtual 函数返回值类型虚函数名（形参表）{ 函数体 }
常见的不能声明为虚函数的有：普通函数（非成员函数）、静态成员函数、内联成员函数、构造函数、友元函数。
(1)普通函数不能声明为虚函数。普通函数（非成员函数）只能被重载（overload），不能被重写（override），声明为虚函数也没有什么意思，因此编译器会在编译时绑定函数。
(2) 构造函数不能声明为虚函数。构造函数一般用来初始化对象，只有在一个对象生成之后，才能发挥多态作用。如果将构造函数声明为虚函数，则表现为在对象还没有生成的时候来定义它的多态，这两点是不统一的。另外，构造函数不能被继承，因而不能声明为虚函数。
(3) 静态成员函数不能声明为虚函数。静态成员函数对于每个类来说只有一份代码，所有的对象都共享这份代码，它不归某个对象所有，所以也没有动态绑定的必要性。
(4) 内联（inline）成员函数不能声明为虚函数。内联函数就是为了在代码中直接展开，减少函数调用开销的代价。虚函数是为了在继承后对象能够准确的执行自己的动作，这是不可能统一的。另外，内联函数在编译时被展开，虚函数在运行时才能动态的绑定函数。
(5) 友元函数不能声明为虚函数。友元函数不属于类的成员函数，不能被继承。

设置虚函数时须注意以下几点：
只有类的成员函数才能说明为虚函数；
静态成员函数不能是虚函数；
内联函数不能为虚函数；
构造函数不能是虚函数；
析构函数可以是虚函数，而且通常声明为虚函数。



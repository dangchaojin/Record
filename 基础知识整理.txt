1、c++三大特性，分别作用；三种继承的特点；
继承：一个对象获得另一个对象的属性和方法        作用：减少重复的代码，继承是多态的前提。

编译器总是在调用派生类构造函数之前调用基类构造函数。这个顺序在派生类对象销毁时就刚好反过来，即派生类中的析构函数在基类的析构函数之前调用。
构造函数：缺省构造函数时，系统将自动调用该缺省构造函数初始化对象，缺省构造函数会将所有数据成员都初始化为零或空
析构函数：析构函数没有参数，也没有返回值。不能重载，也就是说，一个类中只可能定义一个析构函数。如果一个类中没有定义析构函数，系统也会自动生成一个默认的析构函数，为空函数，什么都不做
                调用条件：a.在函数体内定义的对象，当函数执行结束时，该对象所在类的析构函数会被自动调用；  b.用new运算符动态构建的对象，在使用delete运算符释放它时。

封装：把客观事物封装成抽象的类，隐藏对象的属性和实现细节，仅仅对外提供接口和方法，类可以把自己的数据和方法只让可信的类或者对象操作
    隔离变化，便于使用，提高重用性，提高安全性

多态：向不同对象发生同一个消息，不同的对象在接收时会产生不同的行为(即方法)，分为动多态(运行期多态) 和 静多态(编译期多态)，而静多态主要通过模板、函数重载和运算符重载、宏多态来实现。动多态在C++中是通过虚函数实现的，即在基类中存在一些接口（一般为纯虚函数），子类必须重载这些接口。这样通过使用基类的指针或者引用指向子类的对象，就可以实现调用子类对应的函数的功能。动多态的函数调用机制是执行期才能进行确定，所以它是动态的。
    大大提高了代码的可复用性，提高了了代码的可维护性，可扩充性；
	
封装可以隐藏实现细节，使得代码模块化，继承可以扩展已存在的模块，它们目的都是为了：代码重用。而多态是为了实现另一个目的：接口重用。


2、虚析构函数、虚函数、虚继承、虚基类    什么函数不可以被定义为虚函数（详解见文末）
虚析构函数：被virtual关键字修饰的析构函数。    为了解决用一个基类的指针删除一个派生类的对象时，派生类的析构函数会被调用。
虚函数：被virtual关键字修饰的成员函数。    实现多态性，多态性是将接口与实现进行分离
虚继承：继承方式前面加上virtual关键字。    为了解决多继承时的命名冲突和冗余数据问题，使得在派生类中只保留一份间接基类的成员
虚基类：虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类

一个类有一个或者一个以上的虚函数，则该类有且只有一张虚函数表，每个类都只有一个虚函数表，该类的所有对象都共享这张虚函数表

不可以被定义为虚函数的：普通函数（非成员函数）、静态成员函数、内联成员函数、构造函数、友元函数


3、重载、重写（覆盖）、隐藏、
重载：同一作用域内被声明的几个具有不同参数列表（参数类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型
重写（覆盖）：在派生类中被重新定义的虚函数。（其函数名，参数列表，都必须同基类中被重写的函数一致）
隐藏（重定义）：是指派生类的函数屏蔽了与其同名的基类函数，注意只要同名函数并且基类没有virtual修饰，不管参数列表是否相同，基类函数都会被隐藏。


5、new/delete和malloc/free区别联系
a.最大区别是对对象的理解：malloc只是单纯的分配空间，而不是想创建一个对象，new会先分配空间然后调用构造函数来初始化空间变成对象。delete会先调用析构函数再释放空间。   本质：new\delete玩的是对象，而malloc\free仅仅是bai存空间而已
b.malloc/free为C的标准库函数，new/delete则为C++的操作运算符，调用的分别为赋值运算符重载operator new()和operator delete()；
c.malloc返回类型为void*，必须强制类型转换对应类型指针，new则直接返回对应类型指针；
d.malloc开辟的内存永远是通过free来释放的；而new单个元素内存，用的是delete，如果new[]数组，用的是delete[]来释放内存的。
e.malloc开辟内存时返回内存地址要检查判空，因为若它可能开辟失败会返回NULL；new则不用判断，因为内存分配失败时，它会抛出异常bac_alloc,可以使用异常机制；
f.malloc开辟空间类型大小需手动计算，new是由编译器自己计算；
g.new/delete底层是基于malloc/free来实现的；
h.new/delete是操作符，它调用operator new / operator delete,它们可以被重载，在标准库里它有8个重载版本；而malloc/free不可以重载；
i.对于malloc分配内存后，若在使用过程中内存分配不够或太多，这时可以使用realloc函数对其进行扩充或缩小，但是new分配好的内存不能这样被直观简单的改变；
j.malloc是在堆上分配内存的，new相当于也是在堆上开辟内存的


6、内存中的几个区域      讲一下堆与找的区别与联系（内存分配Heap和stack的区别）



7、拷贝构造函数   一定要引用么？
拷贝构造函数是一种特殊的构造函数，作用就是用来复制对象，(编译器调用)用同一类中之前创建的对象来创建、初始化新对象。

拷贝构造函数形参必须是引用，但并不限制为const。必须是引用传递，不能是值传递原因：为了防止递归引用。
当一个对象需要以值方式传递时，编译器会生成代码调用它的拷贝构造函数以生成一个复本对象。如果类A的拷贝构造函数是以值方式传递一个类A对象作为参数的话，当需要调用类A的拷贝构造函数时，需要以值方式传进一个A的对象作为实参；

通常用于：a、通过使用另一个同类型的对象来初始化新创建的对象。  b、复制对象把它作为参数传递给函数。  c、复制对象，并从函数返回这个对象。

如果在类中没有定义拷贝构造函数，编译器会自动生成一个默认的拷贝函数(浅拷贝)，来进行对象之间非static成员的位拷贝。如果类数据成员带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。
当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致重复释放一块内存两次。
深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。



8、指针与引用区别与联系      以及使用场景
1）相同点： 都是地址的概念；
指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名。
2）不同点：
指针是一个实体，需要分配内存空间。引用只是另一个变量的别名，不需要分配内存空间。
引用只能在定义时被初始化一次，之后不可变；指针可变；引用“从一而终”，指针可以“见异思迁”；
引用没有const，指针有const，const的指针不可变；（也就是说，没有int& const a这种形式，而const int& a这种形式是有的。前者指引用本身即别名不可以改变，这是一定的，因此不需要这种形式，后者指引用所指的值不可以改变）
引用不能为空，指针可以为空；
“sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；
指针和引用的自增(++)运算意义不一样（指针是指向下一个空间，引用时引用的变量值加1）；
不存在指向空值的引用这个事实，意味着使用引用的代码效率比使用指针的要高。因为在使用引用之前不需要测试它的合法性。相反，指针则应该总是要测试防止为空。
引用访问一个变量是直接访问，而指针访问一个变量是间接访问（只是访问，跟寻址方式不一样，注意下）
理论上，对于指针的级数没有限制，但是引用只能是一级。如下：
  int** p1;         // 合法。指向指针的指针
  int*& p2;        // 合法。指向指针的引用
  int&* p3;        // 非法。指向引用的指针是非法的
  int&& p4;       // 非法。指向引用的引用是非法的

常用于函数的参数传递和返回值
使用引用参数的主要原因有两个：  1）程序员能够修改调用函数中的数据对象。  2）通过传递引用而不是整个数据对象，可以提高程序的运行速度。
对于那些函数，它们只使用传递过来的值，而不对值进行修改。
        （1）如果数据对象很小，如内置数据类型或小型结构，使用按值传递。
        （2）如果数据对象是数组，则使用指向const的指针。
        （3）如果数据对象是较大的结构，则使用const指针或者const引用，以提高程序的效率。
        （4）如果数据对象是类对象，则使用const引用。因此，传递类对象参数的标准方式是按引用传递。
对于那些函数，它们需要修改传递过来的值。
       （1）如果数据对象是内置数据类型，则使用指针。
       （2）如果数据对象师叔祖，则只能使用指针。
       （3）如果数据对象是结构。则使用指针或者引用。
       （4）如果数据对象是类对象，则使用引用。

9、指针传递、值传递、引用传递             指针传递与引用传递细节可参考  下面指针和引用讲解
值传递：形参是实参的拷贝，把实际参数的值传递给对应的形式参数，改变形参的值并不会影响外部实参的值。从被调用函数的角度来说，值传递是单向的（实参->形参），参数的值只能传入，不能传出。
void swap(int a, int b)  {     int temp;  temp=a;  a=b;  b=temp;    }

指针传递：形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。指针传递参数本质上是值传递的方式，它所传递的是一个地址值。
void swap(int *a, int *b)  {    int temp;   temp=*a;  *a=*b;  *b=temp;    }

引用传递：形参相当于是实参的“别名”，对形参的操作其实就是对实参的操作，在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。
void swap(int &a, int &b)  {    int temp;  temp=a;  a=b;  b=temp;    }

值传递不如地址传递高效，因为值传递先从实参的地址中取出值，再赋值给形参代入函数计算；而指针则把形参的地址直接指向实参地址，使用时直接取出数据，效率提高，特别在频繁赋值等情况下


10、static、const、volatile关键字的作用及应用范围
修饰函数的局部变量      特点：有默认值0，只执行一次，运行一开始就开辟了内存，内存放在全局
修饰全局函数和全局变量      特点：只能在本源文件使用
修饰类里面的成员变量      不进入类的大小计算，不依赖于类对象的存在而存在（可直接调用，要进行外置声明）
修饰类的成员函数      f():括号里无this指针，只能调用他的本类静态函数和他的静态变量，即是用static修饰过的不依赖于类对象的存在而存在（可不进行外置声明，直接调用）

const 在C++中是用来修饰内置类型变量，自定义对象，成员函数，返回值，函数参数。
const修饰普通类型的变量： const int  a = 7; a被定义为一个常量，并且可以将a赋值给b，但是不能给a再次赋值。
const 修饰指针变量：A:const 修饰指针指向的内容，则内容为不可变量。  B:const 修饰指针，则指针为不可变量。  C:const 修饰指针和指针指向的内容，则指针和指针指向的内容都为不可变量。  （左定值，右定向，const修饰不变量。）
const in function参数传递：A：值传递的const修饰传递，一般这种情况不需要const修饰，因为函数会自动产生临时变量复制实参值。B：当const参数为指针时，可以防止指针被意外篡改。C：自定义类型的参数传递，需要临时对象复制参数，对于临时对象的构造，需要调用构造函数，比较浪费时间，因此我们采取const外加引用传递的方法。
const修饰函数的返回值：const 修饰自定义类型的作为返回值，此时返回的值不能作为左值使用，既不能被赋值，也不能被修改。
const修饰类成员函数：const 修饰类成员函数，其目的是防止成员函数修改被调用对象的值，如果我们不想修改一个调用对象的值，所有的成员函数都应当声明为const成员函数。注意：const关键字不能与static关键字同时使用，因为static关键字修饰静态成员函数，静态成员函数不含有this指针，即不能实例化，const成员函数必须具体到某一实例。尽量按照要求将所有的不需要改变对象内容的函数都作为const成员函数。如果有个成员函数想修改对象中的某一个成员怎么办？这时我们可以使用mutable关键字修饰这个成员，mutable的意思也是易变的，容易改变的意思，被mutable关键字修饰的成员可以处于不断变化中。

volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。
遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问

11、声明和定义
为变量分配地址和存储空间的称为定义，不分配地址的称为声明。一个变量可以在多个地方声明，
但是只在一个地方定义。加入extern修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。说明：很多时候一个变量，只是声明不分配内存空间，直到具体使用时才初始化，分配内存空间，如外部变量。


12、sizeof 和 strlen 的区别
a.sizeof 是一个操作符，strlen 是库函数
b.sizeof 的参数可以是数据的类型，也可以是变量，而 strlen 只能以结尾为‘\0‘的字符串作参数。
c.编译器在编译时就计算出了 sizeof 的结果。而 strlen 函数必须在运行时才能计算出来。并且 sizeof 计算的是数据类型占内存的大小，而 strlen 计算的是字符串实际的长度。


13、c++四种强制类型转化     八种数据结构


14、类与结构体   结构体跟联合体
类中定义的继承和成员变量、成员函数默认都是private属性的，结构体中定义的继承和成员变量、成员函数默认都是public属性的。

struct各成员各自拥有自己的内存，各自使用互不干涉，同时存在的，遵循内存对齐原则。一个struct变量的总长度等于所有成员的长度之和。
union各成员共用一块内存空间，并且同时只有一个成员可以得到这块内存的使用权(对该内存的读写)，各变量共用一个内存首地址。因而，联合体比结构体更节约内存。一个union变量的总长度至少能容纳最大的成员变量，而且要满足是所有成员变量类型大小的整数倍。
对于Union的不同成员赋值，将会对其他成员重写，原来成员的值就不存在了
还有关于struct内存存放顺序的问题以及两者内存对齐方式不同的见下面详解


14、内联函数   使用场景


15、


16、
17、
18、进程和线程的区别与联系？进程间通信方式？



进程间通讯方式：管道、消息队列、信号量、共享内存区、套接字
管道：速度慢，容量有限，只有父子进程能通讯
消息队列：容易受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题
信号量：不能传递复杂消息，只能用来同步
共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存
套接字：可用于不同机器间的进程通信

19、tcp、udp区别联系    网络模型   三次握手细节及原因   四次**
a、TCP面向连接(如打电话要先拨号建立连接)；UDP是无连接的，即发送数据之前不需要建立连接。
b、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。TCP通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。
c、UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。
d、每一条TCP连接只能是点到点的；UDP支持一对一、一对多、多对一和多对多的交互通信。
e、TCP对系统资源要求较多，UDP对系统资源要求较少。


网速的提升给UDP的稳定性提供可靠网络保障，丢包率很低，如果使用应用层重传，能够确保传输的可靠性。
TCP为了实现网络通信的可靠性，使用了复杂的拥塞控制算法，建立了繁琐的握手过程，由于TCP内置的系统协议栈中，极难对其进行改进。


20、







、学到了啥？  下一步规划
、项目的并发量级      有没有性能问题 诊断和优化的生产经验    项目的真实调优过程
、
、设计模式    常用的
、linux常用命令
、算法题

mencpy函数实现
void * my_mencpy(void *dst, void *src, unsigned count)
{
	if(dst == NULL || src == NULL) return NULL;
	char *pdst = (char*)dst;
	char *psrc = (char*)src;
	while(count--)
	{
		*pdst++ = *psrc++;
	}
	return dst;
}


strcpy函数实现
char *my_strcpy(char* dst, const char* src)
{
	if(dst == NULL || src == NULL) return NULL;
	char* temp = dst;
	while( (*dst++ = *src++) != '\0' ) ;
	return temp;
}


冒泡排序、快速排序、二分查找
设计栈  入栈  出栈  找最小元素
设计string  成员
编写简单的回显函数






static作用                   可参考：https://www.cnblogs.com/xuecl/p/12880968.html        https://www.cnblogs.com/songdanzju/p/7422380.html
1.先来介绍它的第一条也是最重要的一条：隐藏。（static函数，static变量均可）
当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性，其它的源文件也能访问。如果加了static，就会对其它源文件隐藏，在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。static可以用作函数和变量的前缀，对于函数来讲，static的作用仅限于隐藏.
warning：不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；

2.static的第二个作用是保持变量内容的持久。（static变量中的记忆功能和全局生存期）
存储在静态存储区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。
PS：如果作为static局部变量在函数内定义，它的生存期为整个源程序，但是其作用域仍与自动变量相同，只能在定义该变量的函数内使用该变量。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；
int fun(){           //此处需要注意作用域，如函数外定义了全局变量count，在函数内count仍是函数内的count
    static int count = 10; //在第一次进入这个函数的时候，变量a被初始化为10！并接着自减1，以后每次进入该函数，a
    return count--;}        //就不会被再次初始化了，仅进行自减1的操作；在static发明前，要达到同样的功能，则只能使用全局变量；
把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域， 限制了它的使用范围。

3.static的第三个作用是默认初始化为0（static变量）
其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。

最后对static的三条作用做一句话总结。首先static的最主要功能是隐藏，其次因为static变量存放在静态存储区，所以它具备持久性和默认值0. 

4.static的第四个作用：C++中的类成员声明static
在类中声明static变量或者函数时，初始化时使用作用域运算符来标明它所属类，因此，静态数据成员是类的成员，而不是对象的成员，这样就出现以下作用：
(1)类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致了它仅能访问类的静态数据和静态成员函数。      
(2)不能将静态成员函数定义为虚函数。      
(3)由于静态成员声明于类中，操作于其外，所以对其取地址操作，就多少有些特殊 ，变量地址是指向其数据类型的指针 ，函数地址类型是一个“nonmember函数指针”。
(4)由于静态成员函数没有this指针，所以就差不多等同于nonmember函数，结果就 产生了一个意想不到的好处：成为一个callback函数，使得我们得以将C++和C-based X W indow系统结合，同时也成功的应用于线程函数身上。 （这条没遇见过）  
(5)static并没有增加程序的时空开销，相反她还缩短了子类对父类静态成员的访问 时间，节省了子类的内存空间。      
(6)静态数据成员在<定义或说明>时前面加关键字static。      
(7)静态数据成员是静态存储的，所以必须对它进行初始化。（程序员手动初始化，否则编译时一般不会报错，但是在Link时会报错误） 
(8)静态成员初始化与一般数据成员初始化不同：初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆；初始化时不加该成员的访问权限控制符private，public等；初始化时使用作用域运算符来标明它所属类； 所以我们得出静态数据成员初始化的格式：<数据类型><类名>::<静态数据成员名>=<值>
(9)为了防止父类的影响，可以在子类定义一个与父类相同的静态变量，以屏蔽父类的影响。这里有一点需要注意：我们说静态成员为父类和子类共享，但我们有重复定义了静态成员，这会不会引起错误呢？不会，我们的编译器采用了一种绝妙的手法：name-mangling 用以生成唯一的标志。

静态成员变量，不属于对象，而属于类。不能在类的内部初始化，类中只能声明，定义需要在类外。类外定义时不用加static关键字，只需要表明类的作用域。
在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。所以调用不依赖对象，所以不能作为虚函数。对多个对象来说，静态数据成员只存储一处，供所有对象共用。



const、Volatile关键字的作用及应用范围             https://www.cnblogs.com/wshisuifeng/p/10873344.html
main(void)
{    const int  a = 7;
    int  *p = (int*)&a;
    *p = 8;
    cout<<a;
}
对于const变量a，我们取变量的地址并转换赋值给 指向int的指针，然后利用*p = 8;重新对变量a地址内的值赋值，然后输出查看a的值。从调试窗口看到a的值被改变为8，但是输出的结果仍然是7。
从结果中我们可以看到，编译器然后认为a的值为一开始定义的7，所以对const a的操作就会产生上面的情况。所以千万不要轻易对const变量设法赋值，这会产生意想不到的行为。
如果不想让编译器察觉到上面到对const的操作，我们可以定义时在const前面加上volatile关键字。Volatile关键字跟const对应相反，是易变的，容易改变的意思。所以不会被编译器优化，编译器也就不会改变对a变量的操作。








指针和引用
从概念上讲。指针从本质上讲就是存放变量地址的一个变量，在逻辑上是独立的，它可以被改变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变。
而引用是一个别名，它在逻辑上不是独立的，它的存在具有依附性，所以引用必须在一开始就被初始化，从而指向一个已经存在的对象，所以引用不能指向空值。而且其引用的对象在其整个生命周期中是不能被改变的（自始至终只能依附于同一个变量）。

在C++中，指针和引用经常用于函数的参数传递，然而，指针传递参数和引用传递参数是有本质上的不同的：
指针传递参数本质上是值传递的方式，它所传递的是一个地址值。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，即在栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。（这里是在说实参指针本身的地址值不会变）
而在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址（int &a的形式）。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。
引用传递和指针传递是不同的，虽然它们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。而对于指针传递的参数，如果改变被调函数中的指针地址，它将影响不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量，那就得使用指向指针的指针，或者指针引用。

从编译的角度来阐述它们之间的区别：程序在编译时分别将指针和引用添加到符号表上，符号表上记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值。符号表生成后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。




结构体跟联合体        参考：https://blog.csdn.net/firefly_2002/article/details/7954458?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param
union u
{
　double a;
　int b;
};
union u2
{
　char a[13];
　int b;
};
union u3
{
　char a[13];
　char b;
};

cout<<sizeof(u)<<endl; // 8
cout<<sizeof(u2)<<endl; // 16
cout<<sizeof(u3)<<endl; // 13
都知道union的大小取决于它所有的成员中，占用空间最大的一个成员的大小。所以对于u来说，大小就是最大的double类型成员a了，所以sizeof(u)=sizeof(double)=8。但是对于u2和u3，最大的空间都是char[13]类型的数组，为什么u3的大小是13，而u2是16呢？关键在于u2中的成员int b。由于int类型成员的存在，使u2的对齐方式变成4，也就是说，u2的大小必须在4的对界上，所以占用的空间变成了16（最接近13的对界）。
结论：复合数据类型，如union，struct，class的对齐方式为成员中对齐方式最大的成员的对齐方式。

顺便提一下CPU对界问题，32的C++采用8位对界来提高运行速度，所以编译器会尽量把数据放在它的对界上以提高内存命中率。对界是可以更改的，使用#pragma pack(x)宏可以改变编译器的对界方式，默认是8。C++固有类型的对界取编译器对界方式与自身大小中较小的一个。例如，指定编译器按2对界，int类型的大小是4，则int的对界为2和4中较小的2。在默认的对界方式下，因为几乎所有的数据类型都不大于默认的对界方式8（除了long double），所以所有的固有类型的对界方式可以认为就是类型自身的大小。更改一下上面的程序：
#pragma pack(2)
union u2
{
　char a[13];  int b;
};
union u3
{
　char a[13];  char b;
};
#pragma pack(8)

cout<<sizeof(u2)<<endl; // 14 由于手动更改对界方式为2，所以int的对界也变成了2，u2的对界取成员中最大的对界，也是2了，所以此时sizeof(u2)=14。
cout<<sizeof(u3)<<endl; // 13 ，char的对界为1
结论：C++固有类型的对界取编译器对界方式与自身大小中较小的一个。

struct的sizeof问题
因为对齐问题使结构体的sizeof变得比较复杂，看下面的例子：(默认对齐方式下)
struct s1
{
　char a;
　double b;
　int c;
　char d;
};
struct s2
{
　char a;
　char b;
　int c;
　double d;
};
cout<<sizeof(s1)<<sizeof(s2)<<endl; // 24 16
//如果去掉double b，就是以剩下的int为准，就是12  8

同样是两个char类型，一个int类型，一个double类型，但是因为对界问题，导致他们的大小不同。计算结构体大小可以采用元素摆放法，我举例子说明一下：首先，CPU判断结构体的对界，根据上一节的结论，s1和s2的对界都取最大的元素类型，也就是double类型的对界8。然后开始摆放每个元素。
对于s1，首先把a放到8的对界，假定是0，此时下一个空闲的地址是1，但是下一个元素d是double类型，要放到8的对界上，离1最接近的地址是8了，所以d被放在了8，此时下一个空闲地址变成了16，下一个元素c的对界是4，16可以满足，所以c放在了16，此时下一个空闲地址变成了20，下一个元素d需要对界1，也正好落在对界上，所以d放在了20，结构体在地址21处结束。由于s1的大小需要是8的倍数，所以21-23的空间被保留，s1的大小变成了24。
对于s2，首先把a放到8的对界，假定是0，此时下一个空闲地址是1，下一个元素的对界也是1，所以b摆放在1，下一个空闲地址变成了2；下一个元素c的对界是4，所以取离2最近的地址4摆放c，下一个空闲地址变成了8，下一个元素d的对界是8，所以d摆放在8，所有元素摆放完毕，结构体在15处结束，占用总空间为16，正好是8的倍数。

特例：
union{    int i;  char x[2];    }a;
void main()  {    a.x[0]=10;  a.x[1]=1;  printf("%d",a.i);    }
存储的时候是“低位在前”，a[0]是00001010，a[1]是00000001
输出的i是将二个字节作为一个整数看，即是x[1]x[0]也就是00000001 00001010      即 256+8+2=266。



new/delete和malloc/free区别联系
new[]/delete[]：在开辟大小会多开辟四个字节，用于存放对象的个数，在返回地址时则会向后偏移4个字节，而在delete时则会查看内存上对象个数，从而根据个数count确定调用几次析构函数，从而完全清理所有对象占用内存。
所以对于内置类型若new[]但用delete释放时，没有影响，但若是自定义类型如类时，若释放使用delete时，这时则会只调用一次析构函数，只析构了一个对象，剩下的对象都没有被清理。
参考：https://blog.csdn.net/weibo1230123/article/details/81980889                



拷贝构造函数参考：https://www.cnblogs.com/alantu2018/p/8459250.html
有拷贝构造函数前提：
void g_fun(CExample c)  {    cout<<"g_func"<<endl;    }
main()  {    CExample A(100);  g_fun(A);    }
调用g_fun()时，会产生以下几个重要步骤：
(1).A对象传入形参时，会先会产生一个临时变量，就叫C吧。
(2).然后调用拷贝构造函数把A的值给C。 整个这两个步骤有点像：CExample C(A);
(3).等g_fun()执行完后, 析构掉C对象。  



什么函数不可以被定义为虚函数详解：
虚函数通过继承方式来体现出多态作用，它必须是基类的非静态成员函数，其访问权限可以是protected或public，在基类的类定义中定义虚函数的一般形式是：
virtual 函数返回值类型虚函数名（形参表）{ 函数体 }
常见的不能声明为虚函数的有：普通函数（非成员函数）、静态成员函数、内联成员函数、构造函数、友元函数。
(1)普通函数不能声明为虚函数。普通函数（非成员函数）只能被重载（overload），不能被重写（override），声明为虚函数也没有什么意思，因此编译器会在编译时绑定函数。
(2) 构造函数不能声明为虚函数。构造函数一般用来初始化对象，只有在一个对象生成之后，才能发挥多态作用。如果将构造函数声明为虚函数，则表现为在对象还没有生成的时候来定义它的多态，这两点是不统一的。另外，构造函数不能被继承，因而不能声明为虚函数。
(3) 静态成员函数不能声明为虚函数。静态成员函数对于每个类来说只有一份代码，所有的对象都共享这份代码，它不归某个对象所有，所以也没有动态绑定的必要性。
(4) 内联（inline）成员函数不能声明为虚函数。内联函数就是为了在代码中直接展开，减少函数调用开销的代价。虚函数是为了在继承后对象能够准确的执行自己的动作，这是不可能统一的。另外，内联函数在编译时被展开，虚函数在运行时才能动态的绑定函数。
(5) 友元函数不能声明为虚函数。友元函数不属于类的成员函数，不能被继承。

设置虚函数时须注意以下几点：
只有类的成员函数才能说明为虚函数；
静态成员函数不能是虚函数；
内联函数不能为虚函数；
构造函数不能是虚函数；
析构函数可以是虚函数，而且通常声明为虚函数。



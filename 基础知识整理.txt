1、c++三大特性，分别作用；三种继承的特点；
继承：一个对象获得另一个对象的属性和方法
     减少重复的代码，继承是多态的前提。

封装：把客观事物封装成抽象的类，隐藏对象的属性和实现细节，仅仅对外提供接口和方法，类可以把自己的数据和方法只让可信的类或者对象操作
    隔离变化，便于使用，提高重用性，提高安全性

多态：向不同对象发生同一个消息，不同的对象在接收时会产生不同的行为（即方法），分为动多态（运行期多态） 和 静多态（编译期多态），而静多态主要通过模板、函数重载和运算符重载、宏多态来实现。动多态在C++中是通过虚函数实现的，即在基类中存在一些接口（一般为纯虚函数），子类必须重载这些接口。这样通过使用基类的指针或者引用指向子类的对象，就可以实现调用子类对应的函数的功能。动多态的函数调用机制是执行期才能进行确定，所以它是动态的。
    大大提高了代码的可复用性，提高了了代码的可维护性，可扩充性；
	
封装可以隐藏实现细节，使得代码模块化，继承可以扩展已存在的模块，它们目的都是为了：代码重用。而多态是为了实现另一个目的：接口重用。


2、虚析构函数、虚函数、虚继承、虚基类    什么函数不可以被定义为虚函数（详解见文末）
虚析构函数：被virtual关键字修饰的析构函数。    为了解决用一个基类的指针删除一个派生类的对象时，派生类的析构函数会被调用。
虚函数：被virtual关键字修饰的成员函数。    实现多态性，多态性是将接口与实现进行分离
虚继承：继承方式前面加上virtual关键字。    为了解决多继承时的命名冲突和冗余数据问题，使得在派生类中只保留一份间接基类的成员
虚基类：虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类

一个类有一个或者一个以上的虚函数，则该类有且只有一张虚函数表，每个类都只有一个虚函数表，该类的所有对象都共享这张虚函数表

不可以被定义为虚函数的：普通函数（非成员函数）、静态成员函数、内联成员函数、构造函数、友元函数


3、重载、重写（覆盖）、隐藏、
重载：同一作用域内被声明的几个具有不同参数列表（参数类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型
重写（覆盖）：在派生类中被重新定义的虚函数。（其函数名，参数列表，都必须同基类中被重写的函数一致）
隐藏（重定义）：是指派生类的函数屏蔽了与其同名的基类函数，注意只要同名函数并且基类没有virtual修饰，不管参数列表是否相同，基类函数都会被隐藏。


4、继承   构造和析构的顺序


5、new/delete和molloc/free区别联系


6、内存中的几个区域      讲一下堆与找的区别与联系（内存分配Heap和stack的区别）



7、拷贝构造函数   一定要引用么？
拷贝构造函数是一种特殊的构造函数，作用就是用来复制对象，（编译器调用）用同一类中之前创建的对象来创建、初始化新对象。

拷贝构造函数形参必须是引用，但并不限制为const。必须是引用传递，不能是值传递原因：为了防止递归引用。
当一个对象需要以值方式传递时，编译器会生成代码调用它的拷贝构造函数以生成一个复本。如果类A的拷贝构造函数是以值方式传递一个类A对象作为参数的话，当需要调用类A的拷贝构造函数时，需要以值方式传进一个A的对象作为实参；

8、指针与引用区别与联系   以及使用场景

9、指针传递、值传递、引用传递
值传递：形参是实参的拷贝，把实际参数的值传递给对应的形式参数，改变形参的值并不会影响外部实参的值。从被调用函数的角度来说，值传递是单向的（实参->形参），参数的值只能传入，不能传出。
void swap(int a, int b)  {     int temp;  temp=a;  a=b;  b=temp;    }

指针传递：形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。指针传递参数本质上是值传递的方式，它所传递的是一个地址值。
void swap(int *a, int *b)  {    int temp;   temp=*a;  *a=*b;  *b=temp;    }

引用传递：形参相当于是实参的“别名”，对形参的操作其实就是对实参的操作，在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。
void swap(int &a, int &b)  {    int temp;  temp=a;  a=b;  b=temp;    }




10、static、const关键字的作用及应用范围




13、c++四种强制类型转化     八种数据结构


14、内联函数   使用场景


15、


16、
17、
18、进程和线程的区别与联系？进程间通信方式？



进程间通讯方式：管道、消息队列、信号量、共享内存区、套接字
管道：速度慢，容量有限，只有父子进程能通讯
消息队列：容易受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题
信号量：不能传递复杂消息，只能用来同步
共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存
套接字：可用于不同机器间的进程通信

19、
20、







、学到了啥？  下一步规划
、项目的并发量级      有没有性能问题 诊断和优化的生产经验    项目的真实调优过程
、tcp、udp区别联系    网络模型   三次握手细节及原因   四次**
、设计模式    常用的
、linux常用命令
、算法题

mencpy函数实现
void * my_mencpy(void *dst, void *src, unsigned count)
{
	if(dst == NULL || src == NULL) return NULL;
	char *pdst = (char*)dst;
	char *psrc = (char*)src;
	while(count--)
	{
		*pdst++ = *psrc++;
	}
	return dst;
}

strcpy函数实现


冒泡排序、快速排序、二分查找
设计栈  入栈  出栈  找最小元素
设计string  成员
编写简单的回显函数





























什么函数不可以被定义为虚函数详解：
虚函数通过继承方式来体现出多态作用，它必须是基类的非静态成员函数，其访问权限可以是protected或public，在基类的类定义中定义虚函数的一般形式是：
virtual 函数返回值类型虚函数名（形参表）{ 函数体 }
常见的不能声明为虚函数的有：普通函数（非成员函数）、静态成员函数、内联成员函数、构造函数、友元函数。
(1)普通函数不能声明为虚函数。普通函数（非成员函数）只能被重载（overload），不能被重写（override），声明为虚函数也没有什么意思，因此编译器会在编译时绑定函数。
(2) 构造函数不能声明为虚函数。构造函数一般用来初始化对象，只有在一个对象生成之后，才能发挥多态作用。如果将构造函数声明为虚函数，则表现为在对象还没有生成的时候来定义它的多态，这两点是不统一的。另外，构造函数不能被继承，因而不能声明为虚函数。
(3) 静态成员函数不能声明为虚函数。静态成员函数对于每个类来说只有一份代码，所有的对象都共享这份代码，它不归某个对象所有，所以也没有动态绑定的必要性。
(4) 内联（inline）成员函数不能声明为虚函数。内联函数就是为了在代码中直接展开，减少函数调用开销的代价。虚函数是为了在继承后对象能够准确的执行自己的动作，这是不可能统一的。另外，内联函数在编译时被展开，虚函数在运行时才能动态的绑定函数。
(5) 友元函数不能声明为虚函数。友元函数不属于类的成员函数，不能被继承。

设置虚函数时须注意以下几点：
只有类的成员函数才能说明为虚函数；
静态成员函数不能是虚函数；
内联函数不能为虚函数；
构造函数不能是虚函数；
析构函数可以是虚函数，而且通常声明为虚函数。



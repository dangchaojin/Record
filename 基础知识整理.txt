1、c++三大特性，分别作用；三种继承的特点；
继承：一个对象获得另一个对象的属性和方法        作用：减少重复的代码，继承是多态的前提。

编译器总是在调用派生类构造函数之前调用基类构造函数。这个顺序在派生类对象销毁时就刚好反过来，即派生类中的析构函数在基类的析构函数之前调用。
构造函数：缺省构造函数时，系统将自动调用该缺省构造函数初始化对象，缺省构造函数会将所有数据成员都初始化为零或空
析构函数：析构函数没有参数，也没有返回值。不能重载，也就是说，一个类中只可能定义一个析构函数。如果一个类中没有定义析构函数，系统也会自动生成一个默认的析构函数，为空函数，什么都不做
                调用条件：a.在函数体内定义的对象，当函数执行结束时，该对象所在类的析构函数会被自动调用；  b.用new运算符动态构建的对象，在使用delete运算符释放它时。

封装：把客观事物封装成抽象的类，隐藏对象的属性和实现细节，仅仅对外提供接口和方法，类可以把自己的数据和方法只让可信的类或者对象操作
    隔离变化，便于使用，提高重用性，提高安全性

多态：向不同对象发生同一个消息，不同的对象在接收时会产生不同的行为(即方法)，分为动多态(运行期多态) 和 静多态(编译期多态)，而静多态主要通过模板、函数重载和运算符重载、宏多态来实现。动多态在C++中是通过虚函数实现的，即在基类中存在一些接口（一般为纯虚函数），子类必须重载这些接口。这样通过使用基类的指针或者引用指向子类的对象，就可以实现调用子类对应的函数的功能。动多态的函数调用机制是执行期才能进行确定，所以它是动态的。
    大大提高了代码的可复用性，提高了了代码的可维护性，可扩充性；
	
封装可以隐藏实现细节，使得代码模块化，继承可以扩展已存在的模块，它们目的都是为了：代码重用。而多态是为了实现另一个目的：接口重用。


2、虚析构函数、虚函数、虚继承、虚基类    什么函数不可以被定义为虚函数（详解见文末）
虚析构函数：被virtual关键字修饰的析构函数。    为了解决用一个基类的指针删除一个派生类的对象时，派生类的析构函数会被调用。
虚函数：被virtual关键字修饰的成员函数。    实现多态性，多态性是将接口与实现进行分离
虚继承：继承方式前面加上virtual关键字。    为了解决多继承时的命名冲突和冗余数据问题，使得在派生类中只保留一份间接基类的成员
虚基类：虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类

一个类有一个或者一个以上的虚函数，则该类有且只有一张虚函数表，每个类都只有一个虚函数表，该类的所有对象都共享这张虚函数表

不可以被定义为虚函数的：普通函数（非成员函数）、静态成员函数、内联成员函数、构造函数、友元函数


3、重载、重写（覆盖）、隐藏、
重载：同一作用域内被声明的几个具有不同参数列表（参数类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型
重写（覆盖）：在派生类中被重新定义的虚函数。（其函数名，参数列表，都必须同基类中被重写的函数一致）
隐藏（重定义）：是指派生类的函数屏蔽了与其同名的基类函数，注意只要同名函数并且基类没有virtual修饰，不管参数列表是否相同，基类函数都会被隐藏。


5、new/delete和malloc/free区别联系
a.最大区别是对对象的理解：malloc只是单纯的分配空间，而不是想创建一个对象，new会先分配空间然后调用构造函数来初始化空间变成对象。delete会先调用析构函数再释放空间。   本质：new\delete玩的是对象，而malloc\free仅仅是bai存空间而已
b.malloc/free为C的标准库函数，new/delete则为C++的操作运算符，调用的分别为赋值运算符重载operator new()和operator delete()；
c.malloc返回类型为void*，必须强制类型转换对应类型指针，new则直接返回对应类型指针；
d.malloc开辟的内存永远是通过free来释放的；而new单个元素内存，用的是delete，如果new[]数组，用的是delete[]来释放内存的。
e.malloc开辟内存时返回内存地址要检查判空，因为若它可能开辟失败会返回NULL；new则不用判断，因为内存分配失败时，它会抛出异常bac_alloc,可以使用异常机制；
f.malloc开辟空间类型大小需手动计算，new是由编译器自己计算；
g.new/delete底层是基于malloc/free来实现的；
h.new/delete是操作符，它调用operator new / operator delete,它们可以被重载，在标准库里它有8个重载版本；而malloc/free不可以重载；
i.对于malloc分配内存后，若在使用过程中内存分配不够或太多，这时可以使用realloc函数对其进行扩充或缩小，但是new分配好的内存不能这样被直观简单的改变；
j.malloc是在堆上分配内存的，new相当于也是在堆上开辟内存的

6、内存中的几个区域      讲一下堆与找的区别与联系（内存分配Heap和stack的区别）



7、拷贝构造函数   一定要引用么？
拷贝构造函数是一种特殊的构造函数，作用就是用来复制对象，(编译器调用)用同一类中之前创建的对象来创建、初始化新对象。

拷贝构造函数形参必须是引用，但并不限制为const。必须是引用传递，不能是值传递原因：为了防止递归引用。
当一个对象需要以值方式传递时，编译器会生成代码调用它的拷贝构造函数以生成一个复本对象。如果类A的拷贝构造函数是以值方式传递一个类A对象作为参数的话，当需要调用类A的拷贝构造函数时，需要以值方式传进一个A的对象作为实参；

通常用于：a、通过使用另一个同类型的对象来初始化新创建的对象。  b、复制对象把它作为参数传递给函数。  c、复制对象，并从函数返回这个对象。

如果在类中没有定义拷贝构造函数，编译器会自动生成一个默认的拷贝函数(浅拷贝)，来进行对象之间非static成员的位拷贝。如果类数据成员带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。
当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致重复释放一块内存两次。
深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。


8、指针与引用区别与联系   以及使用场景



9、指针传递、值传递、引用传递
值传递：形参是实参的拷贝，把实际参数的值传递给对应的形式参数，改变形参的值并不会影响外部实参的值。从被调用函数的角度来说，值传递是单向的（实参->形参），参数的值只能传入，不能传出。
void swap(int a, int b)  {     int temp;  temp=a;  a=b;  b=temp;    }

指针传递：形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。指针传递参数本质上是值传递的方式，它所传递的是一个地址值。
void swap(int *a, int *b)  {    int temp;   temp=*a;  *a=*b;  *b=temp;    }

引用传递：形参相当于是实参的“别名”，对形参的操作其实就是对实参的操作，在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。
void swap(int &a, int &b)  {    int temp;  temp=a;  a=b;  b=temp;    }




10、static、const关键字的作用及应用范围


11、声明和定义
为变量分配地址和存储空间的称为定义，不分配地址的称为声明。一个变量可以在多个地方声明，
但是只在一个地方定义。加入 extern 修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。说明：很多时候一个变量，只是声明不分配内存空间，直到具体使用时才初始化，分配内存空间，
如外部变量。


12、sizeof 和 strlen 的区别
a.sizeof 是一个操作符，strlen 是库函数
b.sizeof 的参数可以是数据的类型，也可以是变量，而 strlen 只能以结尾为‘\0‘的字符串作参数。
c.编译器在编译时就计算出了 sizeof 的结果。而 strlen 函数必须在运行时才能计算出来。并且 sizeof 计算的是数据类型占内存的大小，而 strlen 计算的是字符串实际的长度。


13、c++四种强制类型转化     八种数据结构


14、类与结构体   结构体跟联合体
类中定义的继承和成员变量、成员函数默认都是private属性的，结构体中定义的继承和成员变量、成员函数默认都是public属性的。

struct各成员各自拥有自己的内存，各自使用互不干涉，同时存在的，遵循内存对齐原则。一个struct变量的总长度等于所有成员的长度之和。
union各成员共用一块内存空间，并且同时只有一个成员可以得到这块内存的使用权(对该内存的读写)，各变量共用一个内存首地址。因而，联合体比结构体更节约内存。一个union变量的总长度至少能容纳最大的成员变量，而且要满足是所有成员变量类型大小的整数倍。
对于Union的不同成员赋值，将会对其他成员重写，原来成员的值就不存在了
还有关于struct内存存放顺序的问题以及两者内存对齐方式不同的见下面详解


14、内联函数   使用场景


15、


16、
17、
18、进程和线程的区别与联系？进程间通信方式？



进程间通讯方式：管道、消息队列、信号量、共享内存区、套接字
管道：速度慢，容量有限，只有父子进程能通讯
消息队列：容易受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题
信号量：不能传递复杂消息，只能用来同步
共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存
套接字：可用于不同机器间的进程通信

19、tcp、udp区别联系    网络模型   三次握手细节及原因   四次**
a、TCP面向连接(如打电话要先拨号建立连接)；UDP是无连接的，即发送数据之前不需要建立连接。
b、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。TCP通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。
c、UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。
d、每一条TCP连接只能是点到点的；UDP支持一对一、一对多、多对一和多对多的交互通信。
e、TCP对系统资源要求较多，UDP对系统资源要求较少。


网速的提升给UDP的稳定性提供可靠网络保障，丢包率很低，如果使用应用层重传，能够确保传输的可靠性。
TCP为了实现网络通信的可靠性，使用了复杂的拥塞控制算法，建立了繁琐的握手过程，由于TCP内置的系统协议栈中，极难对其进行改进。


20、







、学到了啥？  下一步规划
、项目的并发量级      有没有性能问题 诊断和优化的生产经验    项目的真实调优过程
、
、设计模式    常用的
、linux常用命令
、算法题

mencpy函数实现
void * my_mencpy(void *dst, void *src, unsigned count)
{
	if(dst == NULL || src == NULL) return NULL;
	char *pdst = (char*)dst;
	char *psrc = (char*)src;
	while(count--)
	{
		*pdst++ = *psrc++;
	}
	return dst;
}

strcpy函数实现


冒泡排序、快速排序、二分查找
设计栈  入栈  出栈  找最小元素
设计string  成员
编写简单的回显函数














结构体跟联合体        参考：https://blog.csdn.net/firefly_2002/article/details/7954458?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param
union u
{
　double a;
　int b;
};
union u2
{
　char a[13];
　int b;
};
union u3
{
　char a[13];
　char b;
};

cout<<sizeof(u)<<endl; // 8
cout<<sizeof(u2)<<endl; // 16
cout<<sizeof(u3)<<endl; // 13
都知道union的大小取决于它所有的成员中，占用空间最大的一个成员的大小。所以对于u来说，大小就是最大的double类型成员a了，所以sizeof(u)=sizeof(double)=8。但是对于u2和u3，最大的空间都是char[13]类型的数组，为什么u3的大小是13，而u2是16呢？关键在于u2中的成员int b。由于int类型成员的存在，使u2的对齐方式变成4，也就是说，u2的大小必须在4的对界上，所以占用的空间变成了16（最接近13的对界）。
结论：复合数据类型，如union，struct，class的对齐方式为成员中对齐方式最大的成员的对齐方式。

顺便提一下CPU对界问题，32的C++采用8位对界来提高运行速度，所以编译器会尽量把数据放在它的对界上以提高内存命中率。对界是可以更改的，使用#pragma pack(x)宏可以改变编译器的对界方式，默认是8。C++固有类型的对界取编译器对界方式与自身大小中较小的一个。例如，指定编译器按2对界，int类型的大小是4，则int的对界为2和4中较小的2。在默认的对界方式下，因为几乎所有的数据类型都不大于默认的对界方式8（除了long double），所以所有的固有类型的对界方式可以认为就是类型自身的大小。更改一下上面的程序：
#pragma pack(2)
union u2
{
　char a[13];  int b;
};
union u3
{
　char a[13];  char b;
};
#pragma pack(8)

cout<<sizeof(u2)<<endl; // 14 由于手动更改对界方式为2，所以int的对界也变成了2，u2的对界取成员中最大的对界，也是2了，所以此时sizeof(u2)=14。
cout<<sizeof(u3)<<endl; // 13 ，char的对界为1
结论：C++固有类型的对界取编译器对界方式与自身大小中较小的一个。

struct的sizeof问题
因为对齐问题使结构体的sizeof变得比较复杂，看下面的例子：(默认对齐方式下)
struct s1
{
　char a;
　double b;
　int c;
　char d;
};
struct s2
{
　char a;
　char b;
　int c;
　double d;
};
cout<<sizeof(s1)<<sizeof(s2)<<endl; // 24 16
//如果去掉double b，就是以剩下的int为准，就是12  8

同样是两个char类型，一个int类型，一个double类型，但是因为对界问题，导致他们的大小不同。计算结构体大小可以采用元素摆放法，我举例子说明一下：首先，CPU判断结构体的对界，根据上一节的结论，s1和s2的对界都取最大的元素类型，也就是double类型的对界8。然后开始摆放每个元素。
对于s1，首先把a放到8的对界，假定是0，此时下一个空闲的地址是1，但是下一个元素d是double类型，要放到8的对界上，离1最接近的地址是8了，所以d被放在了8，此时下一个空闲地址变成了16，下一个元素c的对界是4，16可以满足，所以c放在了16，此时下一个空闲地址变成了20，下一个元素d需要对界1，也正好落在对界上，所以d放在了20，结构体在地址21处结束。由于s1的大小需要是8的倍数，所以21-23的空间被保留，s1的大小变成了24。
对于s2，首先把a放到8的对界，假定是0，此时下一个空闲地址是1，下一个元素的对界也是1，所以b摆放在1，下一个空闲地址变成了2；下一个元素c的对界是4，所以取离2最近的地址4摆放c，下一个空闲地址变成了8，下一个元素d的对界是8，所以d摆放在8，所有元素摆放完毕，结构体在15处结束，占用总空间为16，正好是8的倍数。

特例：
union{    int i;  char x[2];    }a;
void main()  {    a.x[0]=10;  a.x[1]=1;  printf("%d",a.i);    }
存储的时候是“低位在前”，a[0]是00001010，a[1]是00000001
输出的i是将二个字节作为一个整数看，即是x[1]x[0]也就是00000001 00001010      即 256+8+2=266。



new/delete和malloc/free区别联系
new[]/delete[]：在开辟大小会多开辟四个字节，用于存放对象的个数，在返回地址时则会向后偏移4个字节，而在delete时则会查看内存上对象个数，从而根据个数count确定调用几次析构函数，从而完全清理所有对象占用内存。
所以对于内置类型若new[]但用delete释放时，没有影响，但若是自定义类型如类时，若释放使用delete时，这时则会只调用一次析构函数，只析构了一个对象，剩下的对象都没有被清理。
参考：https://blog.csdn.net/weibo1230123/article/details/81980889                



拷贝构造函数参考：https://www.cnblogs.com/alantu2018/p/8459250.html
有拷贝构造函数前提：
void g_fun(CExample c)  {    cout<<"g_func"<<endl;    }
main()  {    CExample A(100);  g_fun(A);    }




什么函数不可以被定义为虚函数详解：
虚函数通过继承方式来体现出多态作用，它必须是基类的非静态成员函数，其访问权限可以是protected或public，在基类的类定义中定义虚函数的一般形式是：
virtual 函数返回值类型虚函数名（形参表）{ 函数体 }
常见的不能声明为虚函数的有：普通函数（非成员函数）、静态成员函数、内联成员函数、构造函数、友元函数。
(1)普通函数不能声明为虚函数。普通函数（非成员函数）只能被重载（overload），不能被重写（override），声明为虚函数也没有什么意思，因此编译器会在编译时绑定函数。
(2) 构造函数不能声明为虚函数。构造函数一般用来初始化对象，只有在一个对象生成之后，才能发挥多态作用。如果将构造函数声明为虚函数，则表现为在对象还没有生成的时候来定义它的多态，这两点是不统一的。另外，构造函数不能被继承，因而不能声明为虚函数。
(3) 静态成员函数不能声明为虚函数。静态成员函数对于每个类来说只有一份代码，所有的对象都共享这份代码，它不归某个对象所有，所以也没有动态绑定的必要性。
(4) 内联（inline）成员函数不能声明为虚函数。内联函数就是为了在代码中直接展开，减少函数调用开销的代价。虚函数是为了在继承后对象能够准确的执行自己的动作，这是不可能统一的。另外，内联函数在编译时被展开，虚函数在运行时才能动态的绑定函数。
(5) 友元函数不能声明为虚函数。友元函数不属于类的成员函数，不能被继承。

设置虚函数时须注意以下几点：
只有类的成员函数才能说明为虚函数；
静态成员函数不能是虚函数；
内联函数不能为虚函数；
构造函数不能是虚函数；
析构函数可以是虚函数，而且通常声明为虚函数。



1、c++三大特性，分别作用；三种继承的特点；
继承：一个对象获得另一个对象的属性和方法        作用：减少重复的代码，继承是多态的前提。

编译器总是在调用派生类构造函数之前调用基类构造函数。这个顺序在派生类对象销毁时就刚好反过来，即派生类中的析构函数在基类的析构函数之前调用。
构造函数：缺省构造函数时，系统将自动调用该缺省构造函数初始化对象，缺省构造函数会将所有数据成员都初始化为零或空
析构函数：析构函数没有参数，也没有返回值。不能重载，也就是说，一个类中只可能定义一个析构函数。如果一个类中没有定义析构函数，系统也会自动生成一个默认的析构函数，为空函数，什么都不做
                调用条件：a.在函数体内定义的对象，当函数执行结束时，该对象所在类的析构函数会被自动调用；  b.用new运算符动态构建的对象，在使用delete运算符释放它时。

封装：把客观事物封装成抽象的类，隐藏对象的属性和实现细节，仅仅对外提供接口和方法，类可以把自己的数据和方法只让可信的类或者对象操作
    隔离变化，便于使用，提高重用性，提高安全性

多态：向不同对象发生同一个消息，不同的对象在接收时会产生不同的行为(即方法)，分为动多态(运行期多态) 和 静多态(编译期多态)，而静多态主要通过模板、函数重载和运算符重载、宏多态来实现。动多态在C++中是通过虚函数实现的，即在基类中存在一些接口（一般为纯虚函数），子类必须重载这些接口。这样通过使用基类的指针或者引用指向子类的对象，就可以实现调用子类对应的函数的功能。动多态的函数调用机制是执行期才能进行确定，所以它是动态的。
    大大提高了代码的可复用性，提高了了代码的可维护性，可扩充性；
	
封装可以隐藏实现细节，使得代码模块化，继承可以扩展已存在的模块，它们目的都是为了：代码重用。而多态是为了实现另一个目的：接口重用。


https://blog.csdn.net/xjbclz/article/details/51811219
2、虚析构函数、虚函数、虚继承、虚基类    什么函数不可以被定义为虚函数（详解见文末）
虚析构函数：被virtual关键字修饰的析构函数。    为了解决用一个基类的指针删除一个派生类的对象时，派生类的析构函数会被调用。
虚函数：被virtual关键字修饰的成员函数。    实现多态性，多态性是将接口与实现进行分离
虚继承：继承方式前面加上virtual关键字。    为了解决多继承时的命名冲突和冗余数据问题，使得在派生类中只保留一份间接基类的成员
虚基类：虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类

一个类有一个或者一个以上的虚函数，则该类有且只有一张虚函数表，每个类都只有一个虚函数表，该类的所有对象都共享这张虚函数表

不可以被定义为虚函数的：普通函数（非成员函数）、静态成员函数、内联成员函数、构造函数、友元函数


3、重载overload、重写override（覆盖）、隐藏hide
重载：同一作用域内被声明的几个具有不同参数列表（参数类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型
重写（覆盖）：在派生类中被重新定义的虚函数。（其函数名，参数列表，都必须同基类中被重写的函数一致）
隐藏（重定义）：是指派生类中的函数屏蔽基类中具有相同名字的非虚函数，注意只要同名函数并且基类没有virtual修饰，不管参数列表是否相同，基类函数都会被隐藏。


5、new/delete和malloc/free区别联系
a.最大区别是对对象的理解：malloc只是单纯的分配空间，而不是想创建一个对象，new会先分配空间然后调用构造函数来初始化空间变成对象。delete会先调用析构函数再释放空间。   本质：new\delete玩的是对象，而malloc\free仅仅是内存空间而已
b.malloc/free为C的标准库函数，new/delete则为C++的操作运算符，调用的分别为赋值运算符重载operator new()和operator delete()；
c.malloc返回类型为void*，必须强制类型转换对应类型指针，new则直接返回对应类型指针；
d.malloc开辟的内存永远是通过free来释放的；而new单个元素内存，用的是delete，如果new[]数组，用的是delete[]来释放内存的。
e.malloc开辟内存时返回内存地址要检查判空，因为若它可能开辟失败会返回NULL；new则不用判断，因为内存分配失败时，它会抛出异常bac_alloc,可以使用异常机制；
f.malloc开辟空间类型大小需手动计算，new是由编译器自己计算（new分配内存按照数据类型进行分配，malloc分配内存按照大小分配）；
g.new/delete底层是基于malloc/free来实现的；
h.new/delete是操作符，它调用operator new / operator delete,它们可以被重载，在标准库里它有8个重载版本；而malloc/free不可以重载；
i.对于malloc分配内存后，若在使用过程中内存分配不够或太多，这时可以使用realloc函数对其进行扩充或缩小，但是new分配好的内存不能这样被直观简单的改变；
j.malloc是在堆上分配内存的，new相当于也是在堆上开辟内存的


6、C++内存中的几个区域
a、栈区（stack）：由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
b、堆区（heap）：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。
c、全局/静态区(static）：全局变量和静态变量的存储是 放在一块的，在程序编译时分配
d、文字常量区：存放常量字符串（这个区域是由系统分配释放？不能由程序员释放？）
e、程序代码区：存放函数体(类的成员函数、全局函数)的二进制代码

c中全局变量分初始化和未初始化，初始化的放在.data段，未初始化的放在.bss段，在C++里则不区分。


7、拷贝构造函数   一定要引用么？
拷贝构造函数是一种特殊的构造函数，作用就是用来复制对象，(编译器调用)用同一类中之前创建的对象来创建、初始化新对象。

拷贝构造函数形参必须是引用，但并不限制为const。必须是引用传递，不能是值传递原因：为了防止递归引用。
当一个对象需要以值方式传递时，编译器会生成代码调用它的拷贝构造函数以生成一个复本对象。如果类A的拷贝构造函数是以值方式传递一个类A对象作为参数的话，当需要调用类A的拷贝构造函数时，需要以值方式传进一个A的对象作为实参；

通常用于：a、通过使用另一个同类型的对象来初始化新创建的对象。  b、复制对象把它作为参数传递给函数。  c、复制对象，并从函数返回这个对象。

如果在类中没有定义拷贝构造函数，编译器会自动生成一个默认的拷贝函数(浅拷贝)，来进行对象之间非static成员的位拷贝。如果类数据成员带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。
当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致重复释放一块内存两次。
深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。



8、指针与引用区别与联系      以及使用场景
1）相同点： 都是地址的概念；
指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名。
2）不同点：
指针是一个实体，需要分配内存空间。引用只是另一个变量的别名，不需要分配内存空间。（这里可以与sizeof(引用名)一起理解，sizeof的结果是原类型的大小）
引用只能在定义时被初始化一次，之后不可变；指针可变；引用“从一而终”，指针可以“见异思迁”；
引用没有const，指针有const，const的指针不可变；（也就是说，没有int& const a这种形式，而const int& a这种形式是有的。前者指引用本身即别名不可以改变，这是一定的，因此不需要这种形式，后者指引用所指的值不可以改变）
引用不能为空，指针可以为空；
“sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；
指针和引用的自增(++)运算意义不一样（指针是指向下一个空间，引用时引用的变量值加1）；
不存在指向空值的引用这个事实，意味着使用引用的代码效率比使用指针的要高。因为在使用引用之前不需要测试它的合法性。相反，指针则应该总是要测试防止为空。
引用访问一个变量是直接访问，而指针访问一个变量是间接访问（只是访问，跟寻址方式不一样，注意下）
理论上，对于指针的级数没有限制，但是引用只能是一级。如下：
  int** p1;         // 合法。指向指针的指针
  int*& p2;        // 合法。指向指针的引用
  int&* p3;        // 非法。指向引用的指针是非法的
  int&& p4;       // 非法。指向引用的引用是非法的

常用于函数的参数传递和返回值
使用引用参数的主要原因有两个：  1）程序员能够修改调用函数中的数据对象。  2）通过传递引用而不是整个数据对象，可以提高程序的运行速度。
对于那些函数，它们只使用传递过来的值，而不对值进行修改。
        （1）如果数据对象很小，如内置数据类型或小型结构，使用按值传递。
        （2）如果数据对象是数组，则使用指向const的指针。
        （3）如果数据对象是较大的结构，则使用const指针或者const引用，以提高程序的效率。
        （4）如果数据对象是类对象，则使用const引用。因此，传递类对象参数的标准方式是按引用传递。
对于那些函数，它们需要修改传递过来的值。
		（1）如果数据对象是内置数据类型，则使用指针。
		（2）如果数据对象是数组，则只能使用指针。
		（3）如果数据对象是结构。则使用指针或者引用。
		（4）如果数据对象是类对象，则使用引用。


9、指针传递、值传递、引用传递             指针传递与引用传递细节可参考  文末指针和引用讲解
值传递：形参是实参的拷贝，把实际参数的值传递给对应的形式参数，改变形参的值并不会影响外部实参的值。从被调用函数的角度来说，值传递是单向的（实参->形参），参数的值只能传入，不能传出。
void swap(int a, int b)  { int temp;  temp=a;  a=b;  b=temp; }

指针传递：形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。指针传递参数本质上是值传递的方式，它所传递的是一个地址值。
void swap(int *a, int *b)  { int temp;   temp=*a;  *a=*b;  *b=temp; }

引用传递：形参相当于是实参的“别名”，对形参的操作其实就是对实参的操作，在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。
void swap(int &a, int &b)  { int temp;  temp=a;  a=b;  b=temp; }

值传递不如地址传递高效，因为值传递先从实参的地址中取出值，再赋值给形参代入函数计算；而指针则把形参的地址直接指向实参地址，使用时直接取出数据，效率提高，特别在频繁赋值等情况下


10、static、const、volatile关键字的作用及应用范围
修饰函数的局部变量      特点：有默认值0，只执行一次，运行一开始就开辟了内存，内存放在全局
修饰全局函数和全局变量      特点：只能在本源文件使用
修饰类里面的成员变量      不进入类的大小计算，不依赖于类对象的存在而存在（可直接调用，要进行外置声明；基类定义的静态成员，将被所有派生类共享。可用 父类名(子类名)::静态成员 或者 父对象(子对象).成员 来访问）注意：从类模板实例化的每个模板类有自己的类模板数据成员，该模板类的所有对象共享一个static数据成员
修饰类的成员函数      f():括号里无this指针，只能调用他的本类静态函数和他的静态变量，即是用static修饰过的不依赖于类对象的存在而存在（可不进行外置声明，直接调用）

const 在C++中是用来修饰内置类型变量，自定义对象，成员函数，返回值，函数参数。
const修饰普通类型的变量： const int a = 7; a被定义为一个常量，并且可以将a赋值给b，但是不能给a再次赋值。
const修饰对象：const A a;  常对象，只能调用常成员函数、更新常成员变量，不能调用普通成员函数。
const修饰指针变量：A:const 修饰指针指向的内容，则内容为不可变量。  B:const 修饰指针，则指针为不可变量。  C:const 修饰指针和指针指向的内容，则指针和指针指向的内容都为不可变量。  （左定值，右定向，const修饰不变量。）
const修饰函数参数：A：值传递的const修饰传递，一般这种情况不需要const修饰，因为函数会自动产生临时变量复制实参值。B：当const参数为指针时，可以防止指针被意外篡改。C：自定义类型的参数传递，需要临时对象复制参数，对于临时对象的构造，需要调用构造函数，比较浪费时间，因此我们采取const外加引用传递，即避免了拷贝，又避免了函数对值的修改。
const修饰函数的返回值：const 修饰自定义类型的作为返回值，此时返回的值不能作为左值使用，既不能被赋值，也不能被修改。
const修饰类成员函数：const 修饰类成员函数，其目的是防止成员函数修改被调用对象的值，如果我们不想修改一个调用对象的值，所有的成员函数都应当声明为const成员函数。注意：const关键字不能与static关键字同时使用，因为static关键字修饰静态成员函数，静态成员函数不含有this指针，即不能实例化，const成员函数必须具体到某一实例。尽量按照要求将所有的不需要改变对象内容的函数都作为const成员函数。如果有个成员函数想修改对象中的某一个成员怎么办？这时我们可以使用mutable关键字修饰这个成员，mutable的意思也是易变的，容易改变的意思，被mutable关键字修饰的成员可以处于不断变化中。

volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。
遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问


11、常量指针、指针常量
常量指针：指向常量的指针，指针指向的是常量，即它不能指向变量，它指向的内容不能被改变，不能通过指针来修改它指向的内容，但是指针自身不是常量，它自身的值可以改变，从而可以指向另一个常量。
指针常量：指针本身是常量。它指向的地址是不可改变的，但地址里的内容可以通过指针改变。它指向的地址将伴其一生，直到生命周期结束。有一点需要注意的是，指针常量在定义时必须同时赋初值。
常量指针使用：如 int b, c;  int const *a;
a = &b;  a = &c;  都可以，唯独它指向的内容不能被修改。如：*a=20;这是违法的！错误！

指针常量使用：如 int a ,b;  int * const p = &a;  表示p是一个常量指针它指向变量a的内存。指针常量不能再用p指向其他变量，如 p = &b; 错误！可以修改指向内存的值，如:* p = 20; 指针常量声明的时候必须像上式那样赋初值。
指针常量也不能释放,用p指向NULL，即 p = NULL; 会在编译时报错。

看const关键字，他后面的不可修改，如int * const a = &b; 后面是a,则说明a不能修改！
常量指针：int const *n; 等价于 const int *n;

    char greeting[] = "Hello";
    char* p1 = greeting;                // 指针变量，指向字符数组变量
    const char* p2 = greeting;          // 常量指针，指向字符数组常量
    char* const p3 = greeting;          // 指针常量，指向字符数组变量
    const char* const p4 = greeting;    // 常指针常量，指向字符数组常量


12、声明和定义
为变量分配地址和存储空间的称为定义，不分配地址的称为声明。一个变量可以在多个地方声明，
但是只在一个地方定义。加入extern修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。说明：很多时候一个变量，只是声明不分配内存空间，直到具体使用时才初始化，分配内存空间，如外部变量。


13、sizeof 和 strlen 的区别
sizeof 是一个操作符，strlen 是库函数
sizeof 的参数可以是数据的类型，也可以是变量，而 strlen 只能以结尾为‘\0‘的字符串作参数。
并且 sizeof 计算的是数据类型占内存的大小，而 strlen 计算的是字符串实际的长度。
编译器在编译时就计算出了 sizeof 的结果。而 strlen 函数必须在运行时才能计算出来。


14、c++四种强制类型转化: static_cast、const_cast、reinterpret_cast和dynamic_cast
static_cast（静态类型转换，编译的时候c++编译器会做类型检查。如int转换成char，基本类型能转换 但是不能转换指针类型）
（1）用于类层次结构中基类和派生类之间指针或引用的转换
     进行上行转换（把派生类的指针或引用转换成基类表示）是安全的。进行下行转换（把基类的指针或引用转换为派生类表示），由于没有动态类型检查，所以是不安全的
（2）用于基本数据类型之间的转换，如把int转换成char。这种转换的安全也要开发人员来保证
（3）把空指针转换成目标类型的空指针
（4）把任何类型的表达式转换为void类型
注意：static_cast不能转换掉类型的const、volitale或者__unaligned属性。

const_cast用于强制去掉不能被修改的常数特性
但需要特别注意的是const_cast不是用于去除变量的常量性，而是去除指向常数对象的指针或引用的常量性，其去除常量性的对象必须为指针或引用。该运算符用来修改类型的const或volatile属性。

reinterpret_cast（若不同类型之间，进行强制类型转换，用reinterpret_cast<>() 进行重新解释）
改变指针或引用的类型、将指针或引用转换为一个足够长度的整形、将整型转换为指针或引用类型。
用法：reinterpret_cast<type_id> (expression)    type-id必须是一个指针、引用、算术类型、函数指针或者成员指针。
它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）。
在使用reinterpret_cast强制转换过程仅仅只是比特位的拷贝，因此在使用过程中需要特别谨慎！

dynamic_cast<type_id> (expression)      （dynamic_cast	动态类型转换。安全的基类和子类之间的多态类型转换，运行时类型检查）（还可以用dynamic_pointer_cast）
（1）其他三种都是编译时完成的，dynamic_cast是运行时处理的，运行时要进行类型检查。
（2）不能用于内置的基本数据类型的强制转换。
（3）dynamic_cast转换如果成功的话返回的是指向类的指针或引用，转换失败的话则会返回NULL。
（4）使用dynamic_cast进行转换的，基类中一定要有虚函数，否则编译不通过。基类中需要检测有虚函数的原因：类中存在虚函数，就说明它有想要让基类指针或引用指向派生类对象的情况，此时转换才有意义。这是由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表中，只有定义了虚函数的类才有虚函数表。
（5）在类的转换时，在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的。在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。向上转换，即为子类指针指向父类指针（一般不会出问题）；向下转换，即将父类指针转化子类指针。向下转换的成功与否还与将要转换的类型有关，即要转换的指针指向的对象的实际类型与转换以后的对象类型一定要相同，否则转换失败。在C++中，编译期的类型转换有可能会在运行时出现错误，特别是涉及到类对象的指针或引用操作时，更容易产生错误。Dynamic_cast操作符则可以在运行期对可能产生问题的类型转换进行测试。


15、c++ 八种基本数据类型
整型：
byte：-2^7 ~ 2^7-1，即-128 ~ 127。1字节。末尾加B
short：-2^15 ~ 2^15-1，即-32768 ~ 32767。2字节。末尾加S
有符号int：-2^31 ~ 2^31-1，即-2147483648 ~ 2147483647。4字节。
无符号int：0~2^32-1。
long：-2^63 ~ 2^63-1，即-9223372036854774808 ~ 9223372036854774807。4字节。末尾加L。（也可以不加L）
浮点型：
float：4字节。末尾加F。（也可以不加F）
double：8字节。
字符型：
char：1字节。
布尔型：
boolean：1字节。boolean类型与其他基本类型不能进行类型的转换(既不能进行自动类型的提升，也不能强制类型转换)，否则将编译出错。

两个数值进行二元操作时，会有如下的转换操作：如果两个操作数其中有一个是double类型，另一个操作就会转换为double类型。如果其中一个操作数是float类型，另一个将会转换为float类型。如果其中一个操作数是long类型，另一个会转换为long类型。否则，两个操作数都转换为int类型。
当对小于int的数据类型（byte, char, short）进行运算时，首先会把这些类型的变量值强制转为int类型进行计算，最后会得到int类型的值。因此，如果把2个short类型的值相加，最后得到的结果是int类型，如果需要得到short类型的结果，就必须显示地运算结果转为short类型。


16、类class与结构体struct   结构体struct跟联合体union
类中定义的继承和成员变量、成员函数默认都是private属性的，结构体中定义的继承和成员变量、成员函数默认都是public属性的。

struct各成员各自拥有自己的内存，各自使用互不干涉，同时存在的，遵循内存对齐原则。一个struct变量的总长度等于所有成员的长度之和。
union各成员共用一块内存空间，并且同时只有一个成员可以得到这块内存的使用权(对该内存的读写)，各变量共用一个内存首地址。因而，联合体比结构体更节约内存。一个union变量的总长度至少能容纳最大的成员变量，而且要满足是所有成员变量类型大小的整数倍。
对于Union的不同成员赋值，将会对其他成员重写，原来成员的值就不存在了
还有关于struct内存存放顺序的问题以及两者内存对齐方式不同的见下面详解


17、内联函数                      重点：编译期
不是在调用时发生控制转移，而是在编译时将函数体嵌入在每一个调用处，适用于功能简单，规模较小又使用频繁的函数。递归函数无法内联处理，内联函数不能有循环体，switch语句，不能进行异常接口声明。
内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。

内联函数和宏的区别在于，宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的。而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。你可以象调用函数一样来调用内联函数，而不必担心会产生于处理宏的一些问题。内联函数与带参数的宏定义进行下比较，它们的代码效率是一样，但是内联欢函数要优于宏定义，因为内联函数遵循的类型和作用域规则，它与一般函数更相近，在一些编译器中，一旦关联上内联扩展，将与一般函数一样进行调用，比较方便。 
另外，宏定义在使用时只是简单的文本替换，并没有做严格的参数检查，也就不能享受C++编译器严格类型检查的好处，一些在宏中的编译错误很难发现，另外它的返回值也不能被强制转换为可转换的合适的类型，这样，它的使用就存在着一系列的隐患和局限性。
内联函数不能包括复杂的控制语句，如循环语句和switch语句；
只将规模很小（一般5个语句一下）而使用频繁的函数声明为内联函数。在函数规模很小的情况下，函数调用的时间开销可能相当于甚至超过执行函数本身的时间，把它定义为内联函数，可大大减少程序运行时间。


18、指针函数、函数指针
最简单的辨别方式就是看函数名前面的指针*号有没有被括号（）包含，如果被包含就是函数指针，反之则是指针函数。

指针函数是指返回值为指针的函数，即本质是一个函数。
类型标识符 *函数名(参数表)   int *f(x，y);

函数指针是指向函数的指针变量，即本质是一个指针变量。指向函数的指针包含了函数的地址的入口地址，可以通过它来调用函数。
类型说明符 (*函数名)   (参数)    void (*fptr)();
把函数的地址赋值给函数指针，可以采用下面两种形式：fptr=&Function; 或者 fptr=Function;
取地址运算符&不是必需的，因为单单一个函数标识符就标号表示了它的地址，如果是函数调用，还必须包含一个圆括号括起来的参数表。
可以采用如下两种方式来通过指针调用函数：x=(*fptr)(); 或者 x=fptr();


19、大端、小端 (https://www.cnblogs.com/chanchan/p/7820508.html)   网络序、字节序
大小端是面向多字节类型定义的，比如2字节、4字节、8字节整型、长整型、浮点型等，单字节的字符串一般不用考虑。大端小端存储、传输、以及接收处理需要对应。网络字节序一般是指大端传输。
大端：就是高字节在前，内存存储体现上，数据的高位更加靠近低地址。（低地址存高字节）
小端：就是低字节在前，内存存储体现上，数据的低位更加靠近低地址。（低地址存低字节）
htonl()--"Host to Network Long"
ntohl()--"Network to Host Long"
htons()--"Host to Network Short"
ntohs()--"Network to Host Short" 

主机序有大端小端，网络序用大端。

假设一个32位 unsigned int型数据0x12 34 56 78，大小端8位存储方式如下：
大端存储方式为0x12 34 56 78
小端存储方式为0x78 56 34 12

判断大小端程序：
int i = 0x12345678;
if (*((char*)&i) == 0x12)
    cout << "大端" << endl;
else    
    cout << "小端" << endl;



20、基于对象和面向对象的区别
通常“基于对象”是使用对象，但是无法利用现有的对象模板产生新的对象类型，继而产生新的对象，也就是说“基于对象”没有继承的特点。而“多态”表示为父类类型的子类对象实例，没有了继承的概念也就无从谈论“多态”。现在的很多流行技术都是基于对象的，它们使用一些封装好的对象，调用对象的方法，设置对象的属性。但是它们无法让程序员派生新对象类型。他们只能使用现有对象的方法和属性。
“面向对象”和“基于对象”都实现了“封装”的概念，但是面向对象实现了“继承和多态”。简单地说:基于对象不能继承,更谈不上多态。


21、进程和线程的区别与联系？进程间通信方式？
进程（Process） 是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。 在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。
线程（thread） 是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。

a）进程是资源分配的最小单位，线程是程序执行的最小单位（资源调度的最小单位）。
b）进程有自己的独立的地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程小很多，同时创建一个线程的开销也远比进程要小很多。
c）线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式(IPC)进行。
d）但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另一个进程造成影响，因为进程有自己独立的地址空间。

进程间通讯方式：管道、消息队列、信号量、共享内存区、套接字
管道：速度慢，容量有限，只有父子进程能通讯
消息队列：容易受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题
信号量：不能传递复杂消息，只能用来同步
共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存
套接字：可用于不同机器间的进程通信


22、tcp、udp区别联系   （tcp三次握手细节及原因   四次**）    分别列举应用场景？      分别编程步骤？
a、TCP面向连接(如打电话要先拨号建立连接)；UDP是无连接的，即发送数据之前不需要建立连接。
b、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。TCP通过校验和checksum，重传控制，序号标识，滑动窗口机制、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。（UDP程序结构较简单 导致 TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证）
c、UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。
d、每一条TCP连接只能是点到点的；UDP支持一对一、一对多、多对一和多对多的交互通信。
e、TCP对系统资源要求较多，UDP对系统资源要求较少。
f、流模式与数据报模式 ：TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的。
g、TCP首部开销20字节;UDP的首部开销小，只有8个字节。
h、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。

三次握手                       SYN：同步序列编号（Synchronize Sequence Numbers）。
第一次握手：建立连接时，客户端发送syn包（seq=j）到服务器，并进入SYN_SENT状态，等待服务器确认；
第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（seq=k），即SYN+ACK包，此时服务器进入SYN_RECV状态。
第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。


网速的提升给UDP的稳定性提供可靠网络保障，丢包率很低，如果使用应用层重传，能够确保传输的可靠性。
TCP为了实现网络通信的可靠性，使用了复杂的拥塞控制算法，建立了繁琐的握手过程，由于TCP内置的系统协议栈中，极难对其进行改进。


23、#include < >和#include“ ”的区别
<>：只去系统目录中找头文件，标准的头文件就使用这个方法。
""：会先在当前目录下寻找，如果找不到再去系统目录下寻找，适用于自己定义的头文件


24、匿名对象（临时对象）的生命周期只是定义匿名对象（临时对象）的语句期间，语句执行结束，匿名对象（临时对象）生命周期结束。


25、模板由编译器根据实际数据类型实例化，生成可执行代码。实例化的函数。	模板称为模板函数；实例化的类模板称为模板类。

函数模板：使得程序（算法）可以从逻辑功能上抽象，把被处理的对象（数据）类型作为参数传递。	模板把函数或类要处理的数据类型参数化，表现为参数的多态性，称为类属。模板用于表达逻辑结构相同，但具体数据元素类型不同的数据对象的通用行为。
(a) myswap<float>(a, b);   //显示类型调用           (b) myswap(a, b); 		   //自动数据类型推导
编译器并不是把函数模板处理成能够处理任意类的函数; 编译器从函数模板通过具体类型产生不同的函数。编译器会对函数模板进行两次编译; 在声明的地方对模板代码本身进行编译；在调用的地方对参数替换后的代码进行编译。

当函数模板和普通函数都符合调用时，编译器优先选择普通函数;如果函数模板产生更好的匹配，使用函数模板

类模板： 
template <class T>
class A {
public:
	A(T a){ t = a; }
	void print(){ cout << "t: " << t << endl; }
protected:
	T t;
};

// 模板类派生时, 需要具体化模板类. C++编译器需要知道 父类的数据类型具体是什么，要知道父类所占的内存大小是多少 只有数据类型固定下来,才知道如何分配内存 (数据类型的本质:固定大小内存块的别名)
class B : public A<int> {
public:
	B(int a=10, int b=20) : A<int>(a) { this->b = b; }
	void print() {
		A<int>::print();           //调用基类同名函数
		cout << a << b << endl;
	}
private:
	int b;
};


26、Linux /proc/$pid部分内容详解
proc/[pid]/cmdline是一个只读文件，包含进程的完整命令行信息。如果这个进程是zombie进程，则这个文件没有任何内容。
/proc/[pid]/comm包含进程的命令名。
/proc/[pid]/environ显示进程的环境变量。
/proc/[pid]/fd是一个目录，包含进程打开文件的情况。
/proc/[pid]/latency显示哪些代码造成的延时比较大。
/proc/[pid]/maps显示进程的内存区域映射信息。


27、C++的异常处理机制使得异常的引发和异常的处理不必在同一个函数中，这样底层的函数可以着重解决具体问题，而不必过多的考虑异常的处理。上层调用者可以再适当的位置设计对不同类型异常的处理。
异常是专门针对抽象编程中的一系列错误处理的，C++中不能借助函数机制，因为栈结构的本质是先进后出，依次访问，无法进行跳跃，但错误处理的特征却是遇到错误信息就想要转到若干级之上进行重新尝试
抛掷异常的程序段：
void fun()
{
	...
	throw 表达式;
	...
}
捕获并处理异常的程序段：
try{
	复合语句
}
catch (异常类型声明)
	复合语句；
catch (类型（形参）)
	复合语句；
	...
	
如果匹配的处理器未找到，则运行函数terminate将被自动调用，其缺省功能是调用abort终止程序。
异常被抛出后，从进入try块起，到异常被抛掷前，这期间在栈上的构造的所有对象，都会被自动析构。析构的顺序与构造的顺序相反。这一过程称为栈的解旋。(构造函数里抛出的异常例外，因为没有构造成功)


28、C/C++源程序－－>预编译处理(.c)－－>编译、优化程序（.s、.asm）－－>汇编程序(.obj、.o、.a、.ko)－－>链接程序（.exe、.elf、.axf等）
预编译处理:a、宏定义指令，如#define等。b、条件编译指令，如#ifdef等。c、头文件包含指令。d、特殊符号，预编译程序可以识别一些特殊的符号。如在源程序中出现的LINE标识将被解释为当前行号。
编译、优化程序:检查代码的语法错误及将代码编译成为汇编文件；以及编译优化。
汇编程序:将汇编代码翻译成目标文件，这时的文件已经是二进制代码了。在windows环境下文件的后缀名是.obj，不可执行，需要链接够才可以执行；而在unix下则有是o、.a、.ko等文件。目标文件由段组成。通常一个目标文件中至少有两个段： 代码段：该段中所包含的主要是程序的指令。该段一般是可读和可执行的，但一般却不可写。 数据段：主要存放程序中要用到的各种全局变量或静态的数据。一般数据段都是可读，可写，可执行的。
链接程序:将多个源文件翻译成目标代码后链接到一起才能被执行

由此可见，main函数在cpu中只不过一块代码块，是可以修改的。使用GCC的话，可以通过attribute关键字声明constructor和destructor，在main()函数之前执行一条语句


29、define后面没有;     typedef后面有;

#define pin (int *)    （也不可以这样写）
pin a, b;
本意是a和b都是int型的指针，但是实际上变成 int *a，b;(变成a是int型指针，而b是int型变量)
这里应该使用typedef来代替define，这样a和b就都是int型指针了。即：
typedef pin (int *);
pin a, b;

const定义常量和宏：
const是有数据类型的，可以根据数据类型进行安全检查，发现不匹配的时候，会发出警告或者转换。能转换时就自动进行数据类型转换，不能转换就发出警告
#define就是替换，没有数据类型，无法安全检查
例如：
#define X 10.0
const int num = 10.0;
printf("%zu\n", sizeof(X));  // 8
printf("%d\n", X);  // 显示0或异常（cout打印是10）
printf("%zu\n", sizeof(num));  // 显示4
printf("%d\n", num);  // 10

#加宏定义的妙用
#define SS(x) system(#x)     // 自动给参数x转换为"x"
#define printfNum(x) printf("%s=%d", #x, x)    // 输出变量名和变量

##(连接符)加宏定义的妙用
它是一种预处理运算符，用来把两个语言符号组合成单个语言符号。这里的语言符号不一定是宏的变量，并且双井号不能作为第一个或最后一个元素存在。
#define  I(x)  I##x
#define  P(x)  printf("%s=%d", #x, x)
void main(){
	int I(1)=11, I(2)=22;
	I1=111;   // ##连接符的作用，I(1)等价于I1，所以I(1)的值被修改为111
	I1=222;
	P(I(1));  // I(1)=111
	P(I(2));  // I(2)=222
}





30、explicit关键字作用   https://www.cnblogs.com/gklovexixi/p/5622681.html
在C++中，我们有时可以将构造函数用作自动类型转换函数。但这种自动特性并非总是合乎要求的，有时会导致意外的类型转换，因此，C++新增了关键字explicit，用于关闭这种自动特性。即被explicit关键字修饰的类构造函数，不能进行自动地隐式类型转换，只能显式地进行类型转换。

 

31、野指针、指针悬挂   （指针指向了一块随机的空间，不受程序控制）
	野指针：访问一个已销毁或者访问受限的内存区域的指针，野指针不能判断是否为NULL来避免
	垂悬指针：指针正常初始化，曾指向一个对象，该对象被销毁了，但是指针未制空，那么就成了悬空指针。

产生原因：
	a.指针定义时未被初始化：指针在被定义的时候，如果程序不对其进行初始化的话，它会随机指向一个区域，因为任意指针变量（出了static修饰的指针）它的默认值都是随机的
	b.指针 p 被 free 或者 delete 之后，没有进行置空或者其他赋值操作 (指针悬挂，实际也是野指针)
	c.指针操作超越变量作用域：不要返回指向栈内存的指针或者引用，因为栈内存在函数结束的时候会被释放。

规避方法：
	a.初始化指针的时候将其置为nullptr，之后对其操作。
	b.释放指针的时候将其置为nullptr。
	c.在变量的作用域结束前释放掉变量的地址空间，并且让指针指向NULL。



https://blog.csdn.net/hyqwmxsh/article/details/52813307
32、内存泄漏memory leak、内存溢出out of memory
内存溢出:要求分配的内存超出了系统能给你的，系统不能满足需求，于是产生溢出。
内存泄漏:程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。
检测内存泄露的基本原理: 内存泄露一般指的是堆内存的泄露。检测内存泄露的关键是能截获对分配内存和释放内存的函数的调用。通过截获的这两个函数，我们就能跟踪每一块内存的生命周期。每当成功分配一块内存时，就把它的指针加入一个全局的内存链中；每当释放一块内存时，再把它的指针从内存链中删除。这样当程序运行结束的时候，内存链中剩余的指针就会指向那些没有被释放的内存。

内存溢出是指程序在申请内存时，没有足够的内存空间供其使用。原因可能如下：
	内存中加载的数据量过于庞大，如一次从数据库取出过多数据
	代码中存在死循环或循环产生过多重复的对象实体
	递归调用太深，导致堆栈溢出等
	内存泄漏最终导致内存溢出


32、strcpy、sprintf、memcpy
（1）操作对象不同，strcpy的两个操作对象均为字符串，sprintf的操作源对象可以是多种数据类型，目的操作对象是字符串，memcpy的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。
（2）执行效率不同，memcpy 最高，strcpy 次之，sprintf 的效率最低。
（3）实现功能不同，strcpy 主要实现字符串变量间的拷贝，sprintf主要实现其他数据类型格式到字符串的转化，memcpy主要是内存块间的拷贝。
说明：strcpy、sprintf与memcpy都可以实现拷贝的功能，但是针对的对象不同，根据实际需求，来选择合适的函数实现拷贝功能。


33、C++的空类有哪些成员函数
	缺省构造函数、缺省拷贝构造函数、缺省析构函数、缺省赋值运算符、缺省取址运算符、缺省取址运算符const
注意：有些书上只是简单的介绍了前四个函数。没有提及后面这两个函数。但后面这两个函数也是空类的默认函数。另外需要注意的是，只有当实际使用这些函数的时候，编译器才会去定义它们。


34、this指针的作用
a、this指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向正在被该成员函数操作的那个对象。
b、当对一个对象调用成员函数时，编译程序先将对象的地址赋给this指针，然后调用成员函数，每次成员函数存取数据成员时，由隐含使用this指针。
c、当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。
d、this指针被隐含地声明为: ClassName const this，这意味着不能给this指针赋值；在ClassName类的const成员函数中，this指针的类型为：const ClassName const，这说明不能对this指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；
e、this并不是一个常规变量，而是个右值，所以不能取得this的地址（不能 &amp;this）。

在以下场景中，经常需要显式引用this指针：1)为实现对象的链式引用；2)为避免对同一对象进行赋值操作；3)在实现一些数据结构时，如list。


34、被extern "C"修饰的变量和函数是按照C语言方式编译和连接的，让C++编译器将extern "C"声明的代码当作C语言代码处理，可以避免C++因符号修饰导致代码不能和C语言库中的符号进行链接的问题


35、friend友元类和友元函数
能访问私有成员、破坏封装性、友元关系不可传递、友元关系的单向性、友元声明的形式及数量不受限制


36、::范围解析运算符
全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间
类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的
命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的


37、内存为什么要对齐？
定义：将每一个数据的起始位置，在内存的对其位置处。
性能原因：为了提高程序的性能，经过内存对齐后，CPU的内存访问速度大大提升。（移植原因：某些硬件平台(部分cpu)只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。）
（CPU把内存当成是一块一块的，块的大小可以是2，4，8，16字节大小，因此CPU在读取内存时是一块一块进行读取的。）
原因在于，为了访问未对齐的内存，处理器需要作两次内存访问（还有剔除多余字节数据，合并数据等操作）；然而，对齐的内存访问仅需要一次访问。
一个字或双字操作数跨越了4字节边界，或者一个四字操作数跨越了8字节边界，被认为是未对齐的，从而需要两次总线周期来访问内存。一个字起始地址是奇数但却没有跨越字边界被认为是对齐的，能够在一个总线周期中被访问。



38、auto、decltype(exp)、typeid(exp).name()
auto: 自动类型推导，编译器在编译时期会将auto替换为变量实际的类型。
decltype:从一个变量或表达式中得到其类型
typeid:用来获取一个表达式的类型信息

auto和decltype都用来在编译时期进行自动类型推导。如果表达式的类型是类类型且至少包含有一个虚函数，typeid操作符返回表达式的动态类型需要在运行时计算，否则，typeid返回表达式的静态类型，在编译时就可以计算。
auto根据=右边的初始值推导出变量的类型，而decltype根据表达式推导出变量的类型，跟=右边的初始值没有关系。所以auto要求变量必须初始化，而decltype不要求。

http://c.biancheng.net/view/7151.html
https://www.cnblogs.com/QG-whz/p/4952980.html
https://blog.csdn.net/gatieme/article/details/50947821

模板类型判断需要，可用std::is_same_v判断是否是两个一样的类型      可参考：https://blog.csdn.net/czyt1988/article/details/52812797


39、
const IMSConnectionMap *const IMSControl::GetConnectionMap() const      各个const啥意思


40、


41、


42、


43、



44、




























80、设计模式    常用的
工厂模式、策略模式、适配器模式、单例模式、原型模式、模板模式、建造者模式、外观模式、组合模式、代理模式、享元模式、桥接模式、装饰模式、备忘录模式、中介者模式、职责链模式、观察者模式



81、预处理（Pre-Processing）、编译（Compiling）、汇编（Assembling）、链接（Linking）

g++ 常用编译选项   编译优化等
-E：只进行预处理（宏展开），不编译
-S：只编译，不汇编
-c：只编译、汇编，不链接
-g：包含调试信息，为了gdb 调试用（开了-g，编译时会创建符号表，关闭所有的优化机制）
-o：输出指定文件名
-Idir: 将dir目录加入搜索头文件的目录路径
-Ldir: 将dir目录加入搜索库的目录路径
-llib: 链接lib库

gcc提供了近大量优化选项，用来对编译时间，目标文件长度，执行效率三个维度进行不同的取舍和平衡。
参考：https://blog.csdn.net/wuxing26jiayou/article/details/96132721?utm_medium=distribute.pc_relevant_bbs_down.none-task--2~all~first_rank_v2~rank_v29-3.nonecase&depth_1-utm_source=distribute.pc_relevant_bbs_down.none-task--2~all~first_rank_v2~rank_v29-3.nonecase
https://blog.csdn.net/lee244868149/article/details/38754153?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-7&spm=1001.2101.3001.4242
优化：（编译器可以检测很多问题，需要慢慢学习）
-O0 不进行优化处理。 
-O 或 -O1 优化生成代码。 
-O2 进一步优化。 
-O3 比 -O2 更进一步优化，包括 inline 函数。（4.x一般不建议使用，可能执行效率变化不大但编译时间过长文件长度增加）


-Wall：会打开一些很有用的警告选项，建议编译时加此选项。具体如下：
	-Waddress  -Warray-bounds (only with -O2)   -Wc++0x-compat  -Wchar-subscripts  -Wimplicit-int
	-Wimplicit-function-declaration  -Wcomment -Wformat -Wmain (only for C/ObjC and unless -ffreestanding)
	-Wmissing-braces -Wnonnull -Wparentheses  -Wpointer-sign -Wreorder -Wreturn-type  -Wsequence-point 
	-Wsign-compare (only in C++) -Wstrict-aliasing -Wstrict-overflow=1  -Wswitch -Wtrigraphs
	-Wuninitialized (only with -O1 and above)  -Wunknown-pragmas -Wunused-function
	-Wunused-label -Wunused-value  -Wunused-variable 
-Wextra：打印一些额外的警告信息（对所有合法但值得怀疑的表达式发出警告）
-W 开启所有 gcc 能提供的警告
-w：禁止显示所有警告信息。
-Wshadow：当一个局部变量遮盖住了另一个局部变量，或者全局变量时，给出警告。建议打开。 -Wall 并不会打开此项。
-Wpointer-arith：对函数指针或者void *类型的指针进行算术操作时给出警告。也很有用。 -Wall 并不会打开此项。
-Wcast-qual：当强制转化丢掉了类型修饰符时给出警告。 -Wall 并不会打开此项。
-Wcast-align：一旦某个指针类型强制转换导致目标所需的地址对齐增加时，编译器就发出警告。
-Wundef：当一个没有定义的符号出现在 #if 中时，给出警告。
-Wunreachable-code：如果编译器探测到永远不会执行到的代码，就给出警告。也是比较有用的选项。
-Wunused-but-set-variable：表示一个变量定义了，但是该变量没有被实际应用到。

需要屏蔽时使用-Wno-xxxxxx，如需屏蔽-Wunused-but-set-variable 这一类警告，可以这样添加编译选项：-Wno-unused-but-set-variable

-Werror：把警告当作错误。出现任何警告就放弃编译。
需要指定具体一类时使用-Werror=xxxxxx，如需将没有返回值当error时使用：-Werror=return-type


82、程序运行得比较慢，有什么优化方案
a）编码技巧，汇编，编译器等也是一方面，但是首先要逻辑优化
b）在问如何提高运行速度前 你应该先去了解你的程序慢在哪儿。现成的工具有很多
    比如可以通过火焰图快速的定位程序到底慢在哪里 然后对症下药。
    了解自己的代码做了什么东西，建议用辅助调试工具来检测profile，可以关注下是否有冗余的计算，I/O，锁
c）了解对应的执行环境，硬件差异，系统差异，比如说CPU的特殊指令，GPU与CPU，SSD的写放大，如IOS里面调动态库的执行速度会比同一个静态库的慢些，由于中途多做了一次寻址；SSD上按字节来写可能比按最小块写要慢
d）如果性能相差很多，很可能问题出现在算法上面。就像冒泡排序和快速排序的差距。了解是否有更加合适的算法，一般来说拿空间换时间，或者拿准确度来换时间


83、一些编程小技巧
a、能用引用的地方尽量用引用，这比指针高效，因为引用无需检验
b、针对大的输入量，cin、cout效率比scanf、printf的效率低很多
    原因：cin、cout 是C++对scanf、printf做的封装的类iostream的内容。它们先把要输出的东西存入缓冲区，再输出，导致效率降低。还因为C++为了兼容C，保证程序在使用了std::printf和std::cout的时候不发生混乱，将输出流绑到了一起。
    输出速度：在C++中测试puts()和putchar()是最快的，printf();是第二，最后是cout
    解决方法一：使用以下操作取消兼容，提高速度
    std::ios::sync_with_stdio(0);cout.tie(0);（注意使用了之后，printf和cout不用混用，否则可能出现顺序错乱）
c、new了就要记得delete
   malloc了就要记得free（free时需检查指针是否为空，虽然c++标准允许delete空指针，但是有判空且指针为空时，判空的代码的汇编指令较少; 且delete后赋空）
   open了就要记得close
   add了就要记得remove
d、不要把全局变量以及全局方法的定义放在头文件里！
e、使用memcpy之前先把目标清0！（如memcpy前没清0，赋值时只赋一部分，可能会造成有一部分脏数据或者数据残留）
f、可以用const常量代替define：const修饰的常量编译期间，就已经确定下来了；const常量是由编译器处理的，提供类型检查和作用域检查(c++是强类型语言)，而宏定义由预处理器处理，单纯的文本替换
g、使用内联函数替代宏代码片段(内联函数在编译时直接将函数体插入函数调用的地方，省去了普通函数调用时压栈，跳转和返回的开销)
	对编译器的一种请求，因此编译器可能拒绝这种请求
	内联函数由编译器处理，直接将编译后的函数体插入调用的地方；宏代码片段由预处理器处理，进行简单的文本替换，没有任何编译过程（但有些函数即使声明为内联的也不一定会被编译器内联！比如虚函数和递归函数就不会被编译器正常内联）
h、把结构体中的变量按照类型大小从小到大依次声明，尽量减少中间的填充字节。
i、new内存失败后的正确处理：当用new申请一块内存失败时，抛出异常std::bad_alloc是C++标准规定的标准行为，所以推荐用try{p=new int[SIZE];} catch(std::bad_alloc){…} 的处理方式。但在一些老旧的编译器中，却不支持该标准，会返回NULL，此时采用C传统的Test_for_NULL代码形式。要针对不同的情形采取合理的处置方式。
j、使用内存池技术提高内存申请效率与性能：经典的内存池技术，是一种用于分配大量大小相同的小对象的技术。通过该技术可以极大地加快内存分配/释放过程。内存池技术通过批量申请内存，降低了内存申请次数，从而节省了时间。
k、首选初始化列表实现类成员的初始化
	类成员的初始化可采用两种形式来完成：在构造函数体重赋值完成和用初始化类成员列表完成.
	(1)、const成员变量只能用成员初始化列表来完成初始化，而不能在构造函数内被赋值；(2)、如果类B中含有A类型的成员变量，而类A中又禁止了赋值操作，此时要想顺利地完成B中成员变量的初始化，就必须采用初始化列表方式。即使没有禁用赋值操作，还是不推荐采用函数体内的赋值初始化方式。因为这种方式存在着两种问题。第一，比起初始化列表，此方式效率偏低；第二，留有错误隐患。
    对于初始化列表，初始化的顺序与构造函数中的赋值方式不同，初始化列表中成员变量出现的顺序并不是真正初始化的顺序，初始化的顺序取决于成员变量在类中的声明顺序。只有保证成员变量声明的顺序与初始化列表顺序一致才能真正保证其效率。
l、明智地拒绝对象的复制操作：在某些需要禁止对象复制操作的情形下，可以将这个类相应的拷贝构造函数、赋值操作符operator = 声明为private，并且不要给出实现。或者采用更简单的方法：使用boost::noncopyable作为基类。(联系单例时构造函数及拷贝构造函数声明为私有)
m、谨防因构造函数抛出异常而引发的问题：判断构造对象成功与否，解决办法：抛出一个异常。构造函数抛出异常会引起对象的部分构造，因为不能自动调用析构函数，在异常发生之前分配的资源将得不到及时的清理，进而造成内存泄露问题。所以，如果对象中涉及了资源分配，一定要对构造之中可能抛出的异常做谨慎而细致的处理。
n、小心自定义拷贝函数：如果类内部出现了动态配置的资源，我们就不得不自定义实现其拷贝函数了。在自定义拷贝函数时，应该保证拷贝一个对象的All Parts:所有数据成员及所有的基类部分。
o、多态基类的析构函数应该为虚
	虚函数的最大目的就是允许派生类定制实现。所以，用基类指针删除一个派生类对象时，C++会正确地调用整个析构链，执行正确的行为，以销毁整个对象。在实际使用虚析构函数的过程中，一般要遵守以下规则：当类中包含至少一个虚函数时，才将该类的析构函数声明为虚。因为一个类要作为多态基类使用时，它一定会包含一个需要派生定制的虚函数。相反，如果一个类不包含虚函数，那就预示着这个类不能作为多态基类使用。同样，如果一个类的析构函数非虚，决不能继承它，即使是标准库中的string、complex、以及STL容器。
	多态基类的析构函数应该是virtual的，也必须是virtual的，因为只有这样，虚函数机制才会保证派生类对象的彻底释放；如果一个类有一个虚函数，那么它就该有一个虚析构函数；如果一个类不被设计为基类，那么这个类的析构就应该拒绝为虚。
p、积极使用const为函数保驾护航(作用见上)
q、优化循环，提高效率：应当将最长的循环放在最内层，最短的循环放在最外层，以减少CPU跨切循环层的次数，提高效率。
r、精简函数参数：函数在调用时会建立堆栈来存储所需的参数值，因此函数的调用负担会随着参数列表的增长而增加。所以，参数的个数会影响进栈出栈的次数，当参数很多的时候，这样的操作就会花费很长的时间。因此，精简函数参数，减少参数个数可以提高函数调用的效率。如果精简后的参数还是比较多，那么可以把参数列表封装进一个单独的类中，并且可以通过引用进行传递。
s、用初始化取代赋值：以用户初始化代替赋值，可以使效率得到较大的提升，因为这样可以避免一次赋值函数operator =的调用。因此，当我们在赋值和初始化之间进行选择时，初始化应该是首选。需要注意的是，对基本的内置数据类型而言，初始化和赋值之间是没有差异的，因为内置类型没有构造和析构过程。
t、用表驱动取代冗长的逻辑选择：表驱动法(Table drivenmethod)，是一种不必用很多的逻辑语句(if或case)就可以把表中信息找出来的方法。它是一种设计模式，可用来代替复杂的if/else或switch-case逻辑判断。
u、
v、
w、
x、
y、
z、




84、查bug思路
	a.检测内存泄露的基本原理: 内存泄露一般指的是堆内存的泄露。检测内存泄露的关键是能截获对分配内存和释放内存的函数的调用。通过截获的这两个函数，我们就能跟踪每一块内存的生命周期。每当成功分配一块内存时，就把它的指针加入一个全局的内存链中；每当释放一块内存时，再把它的指针从内存链中删除。这样当程序运行结束的时候，内存链中剩余的指针就会指向那些没有被释放的内存。






https://blog.csdn.net/N1314N/article/details/94652368?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control

https://blog.csdn.net/qq_42627619/article/details/91046831

、学到了啥？  下一步规划

、gdb的使用：1、显示线程；2、一个函数的输出作为另一个函数的输出；3、崩溃文件...

、项目的并发量级      有没有性能问题 诊断和优化的生产经验    项目的真实调优过程

、熟悉mysql关系型数据库以及redis缓存型数据库

、熟悉nginx、libevent多线程开发

、makefile中的优先链接库项deng

、使用学习（详情见PPT）
静态告警：			PClint
通用编程规范检查：	Codingstylecheck
安全编程规范检查：	Codemars
代码质量	圈复杂度：	sourcemonitor、Nsiq



、讲一下堆与找的区别与联系（内存分配Heap和stack的区别）
堆、栈的生长方向，结合上面大小端知识点记录
为啥malloc申请到的堆的空间是连续的？   是因为前面有个空间存储了长度？

堆和栈的区别（见下）
栈是先进先出(还是先进后出)，无法进行跳跃?(联系异常捕获机制)
堆？
两者生长方向？https://www.cnblogs.com/chanchan/p/7820508.html

队列？栈？  队列和栈都是线性存储结构，但是两者的插入和删除数据的操作不同，队列是“先进先出”，栈是“后进先出”。
用两个栈能够实现一个队列的功能，那用两个队列能否实现一个队列的功能呢？结果是否定的，因为栈是先进后出，将两个栈连在一起，就是先进先出。而队列是现先进先出，无论多少个连在一起都是先进先出，而无法实现先进后出。



、七层网络模型、5层网络模型、以及分别对应的协议


、epoll和select的区别是什么？epoll高效率的原因是什么？（分别适用在什么应用场景）




、linux常用命令
    linux怎么看进程下面的线程
    高效地在linux查找：find找文件    grep根据文件内容查找    which查看可执行文件位置    whereis寻找特定文件    locate配合数据库查看文件位置？？（查找文件安装路径？）
    nm  objdump  readelf








(1)、管理方式不同：对于栈来讲，它是由编译器自动管理的，无须我们手工控制；对于堆来说，它的释放工作由程序员控制，容易产生memory leak；
(2)、空间大小不同：一般来讲在32位系统下，堆内存可以达到4GB的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定空间大小的；
(3)、碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而产生大量的碎片，使程序效率降低。对于栈来讲，则不存在这个问题，其原因还要从栈的特殊数据结构说起。栈是一个具有严明纪律的队列，其中的数据必须遵循先进后出的规则，相互之间紧密排列，绝不会留给其他数据可插入之空隙，所以永远都不可能有一个内存块从栈中间弹出，它们必须严格按照一定的顺序一一弹出；
(4)、生成方向：对于堆来讲，其生长方向是向上的，也就是向着内存地址增加的方向增长；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长的；
(5)、分配方式：堆都是动态分配的，没有静态分配的堆。栈有两种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数完成，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放的，无须我们手工实现；
(6)、分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：它会分配专门的寄存器存放栈的地址，而且压栈出栈都会有专门的指令来执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制很复杂，例如为了分配一块内存，库函数会按照一定的算法在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间(可能是由于内存碎片太多)，则可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存了，然后返回。显然，堆的效率比栈要低得多。
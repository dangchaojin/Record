1、c++三大特性，分别作用；三种继承的特点；
继承：一个对象获得另一个对象的属性和方法        作用：减少重复的代码，继承是多态的前提。

编译器总是在调用派生类构造函数之前调用基类构造函数。这个顺序在派生类对象销毁时就刚好反过来，即派生类中的析构函数在基类的析构函数之前调用。
构造函数：缺省构造函数时，系统将自动调用该缺省构造函数初始化对象，缺省构造函数会将所有数据成员都初始化为零或空
析构函数：析构函数没有参数，也没有返回值。不能重载，也就是说，一个类中只可能定义一个析构函数。如果一个类中没有定义析构函数，系统也会自动生成一个默认的析构函数，为空函数，什么都不做
                调用条件：a.在函数体内定义的对象，当函数执行结束时，该对象所在类的析构函数会被自动调用；  b.用new运算符动态构建的对象，在使用delete运算符释放它时。

封装：把客观事物封装成抽象的类，隐藏对象的属性和实现细节，仅仅对外提供接口和方法，类可以把自己的数据和方法只让可信的类或者对象操作
    隔离变化，便于使用，提高重用性，提高安全性

多态：向不同对象发生同一个消息，不同的对象在接收时会产生不同的行为(即方法)，分为动多态(运行期多态) 和 静多态(编译期多态)，而静多态主要通过模板、函数重载和运算符重载、宏多态来实现。动多态在C++中是通过虚函数实现的，即在基类中存在一些接口（一般为纯虚函数），子类必须重载这些接口。这样通过使用基类的指针或者引用指向子类的对象，就可以实现调用子类对应的函数的功能。动多态的函数调用机制是执行期才能进行确定，所以它是动态的。
    大大提高了代码的可复用性，提高了了代码的可维护性，可扩充性；
	
封装可以隐藏实现细节，使得代码模块化，继承可以扩展已存在的模块，它们目的都是为了：代码重用。而多态是为了实现另一个目的：接口重用。


2、虚析构函数、虚函数、虚继承、虚基类    什么函数不可以被定义为虚函数（详解见文末）
虚析构函数：被virtual关键字修饰的析构函数。    为了解决用一个基类的指针删除一个派生类的对象时，派生类的析构函数会被调用。
虚函数：被virtual关键字修饰的成员函数。    实现多态性，多态性是将接口与实现进行分离
虚继承：继承方式前面加上virtual关键字。    为了解决多继承时的命名冲突和冗余数据问题，使得在派生类中只保留一份间接基类的成员
虚基类：虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类

一个类有一个或者一个以上的虚函数，则该类有且只有一张虚函数表，每个类都只有一个虚函数表，该类的所有对象都共享这张虚函数表

不可以被定义为虚函数的：普通函数（非成员函数）、静态成员函数、内联成员函数、构造函数、友元函数


3、重载、重写（覆盖）、隐藏、
重载：同一作用域内被声明的几个具有不同参数列表（参数类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型
重写（覆盖）：在派生类中被重新定义的虚函数。（其函数名，参数列表，都必须同基类中被重写的函数一致）
隐藏（重定义）：是指派生类的函数屏蔽了与其同名的基类函数，注意只要同名函数并且基类没有virtual修饰，不管参数列表是否相同，基类函数都会被隐藏。


5、new/delete和malloc/free区别联系
a.最大区别是对对象的理解：malloc只是单纯的分配空间，而不是想创建一个对象，new会先分配空间然后调用构造函数来初始化空间变成对象。delete会先调用析构函数再释放空间。   本质：new\delete玩的是对象，而malloc\free仅仅是内存空间而已
b.malloc/free为C的标准库函数，new/delete则为C++的操作运算符，调用的分别为赋值运算符重载operator new()和operator delete()；
c.malloc返回类型为void*，必须强制类型转换对应类型指针，new则直接返回对应类型指针；
d.malloc开辟的内存永远是通过free来释放的；而new单个元素内存，用的是delete，如果new[]数组，用的是delete[]来释放内存的。
e.malloc开辟内存时返回内存地址要检查判空，因为若它可能开辟失败会返回NULL；new则不用判断，因为内存分配失败时，它会抛出异常bac_alloc,可以使用异常机制；
f.malloc开辟空间类型大小需手动计算，new是由编译器自己计算（new分配内存按照数据类型进行分配，malloc分配内存按照大小分配）；
g.new/delete底层是基于malloc/free来实现的；
h.new/delete是操作符，它调用operator new / operator delete,它们可以被重载，在标准库里它有8个重载版本；而malloc/free不可以重载；
i.对于malloc分配内存后，若在使用过程中内存分配不够或太多，这时可以使用realloc函数对其进行扩充或缩小，但是new分配好的内存不能这样被直观简单的改变；
j.malloc是在堆上分配内存的，new相当于也是在堆上开辟内存的


6、C++内存中的几个区域
a、栈区（stack）：由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
b、堆区（heap）：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。
c、全局/静态区(static）：全局变量和静态变量的存储是 放在一块的，在程序编译时分配
d、文字常量区：存放常量字符串
e、程序代码区：存放函数体(类的成员函数、全局函数)的二进制代码

c中全局变量分初始化和未初始化，初始化的放在.data段，未初始化的放在.bss段，在C++里则不区分。


7、拷贝构造函数   一定要引用么？
拷贝构造函数是一种特殊的构造函数，作用就是用来复制对象，(编译器调用)用同一类中之前创建的对象来创建、初始化新对象。

拷贝构造函数形参必须是引用，但并不限制为const。必须是引用传递，不能是值传递原因：为了防止递归引用。
当一个对象需要以值方式传递时，编译器会生成代码调用它的拷贝构造函数以生成一个复本对象。如果类A的拷贝构造函数是以值方式传递一个类A对象作为参数的话，当需要调用类A的拷贝构造函数时，需要以值方式传进一个A的对象作为实参；

通常用于：a、通过使用另一个同类型的对象来初始化新创建的对象。  b、复制对象把它作为参数传递给函数。  c、复制对象，并从函数返回这个对象。

如果在类中没有定义拷贝构造函数，编译器会自动生成一个默认的拷贝函数(浅拷贝)，来进行对象之间非static成员的位拷贝。如果类数据成员带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。
当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致重复释放一块内存两次。
深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。



8、指针与引用区别与联系      以及使用场景
1）相同点： 都是地址的概念；
指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名。
2）不同点：
指针是一个实体，需要分配内存空间。引用只是另一个变量的别名，不需要分配内存空间。
引用只能在定义时被初始化一次，之后不可变；指针可变；引用“从一而终”，指针可以“见异思迁”；
引用没有const，指针有const，const的指针不可变；（也就是说，没有int& const a这种形式，而const int& a这种形式是有的。前者指引用本身即别名不可以改变，这是一定的，因此不需要这种形式，后者指引用所指的值不可以改变）
引用不能为空，指针可以为空；
“sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；
指针和引用的自增(++)运算意义不一样（指针是指向下一个空间，引用时引用的变量值加1）；
不存在指向空值的引用这个事实，意味着使用引用的代码效率比使用指针的要高。因为在使用引用之前不需要测试它的合法性。相反，指针则应该总是要测试防止为空。
引用访问一个变量是直接访问，而指针访问一个变量是间接访问（只是访问，跟寻址方式不一样，注意下）
理论上，对于指针的级数没有限制，但是引用只能是一级。如下：
  int** p1;         // 合法。指向指针的指针
  int*& p2;        // 合法。指向指针的引用
  int&* p3;        // 非法。指向引用的指针是非法的
  int&& p4;       // 非法。指向引用的引用是非法的

常用于函数的参数传递和返回值
使用引用参数的主要原因有两个：  1）程序员能够修改调用函数中的数据对象。  2）通过传递引用而不是整个数据对象，可以提高程序的运行速度。
对于那些函数，它们只使用传递过来的值，而不对值进行修改。
        （1）如果数据对象很小，如内置数据类型或小型结构，使用按值传递。
        （2）如果数据对象是数组，则使用指向const的指针。
        （3）如果数据对象是较大的结构，则使用const指针或者const引用，以提高程序的效率。
        （4）如果数据对象是类对象，则使用const引用。因此，传递类对象参数的标准方式是按引用传递。
对于那些函数，它们需要修改传递过来的值。
       （1）如果数据对象是内置数据类型，则使用指针。
       （2）如果数据对象是数组，则只能使用指针。
       （3）如果数据对象是结构。则使用指针或者引用。
       （4）如果数据对象是类对象，则使用引用。

9、指针传递、值传递、引用传递             指针传递与引用传递细节可参考  文末指针和引用讲解
值传递：形参是实参的拷贝，把实际参数的值传递给对应的形式参数，改变形参的值并不会影响外部实参的值。从被调用函数的角度来说，值传递是单向的（实参->形参），参数的值只能传入，不能传出。
void swap(int a, int b)  {     int temp;  temp=a;  a=b;  b=temp;    }

指针传递：形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。指针传递参数本质上是值传递的方式，它所传递的是一个地址值。
void swap(int *a, int *b)  {    int temp;   temp=*a;  *a=*b;  *b=temp;    }

引用传递：形参相当于是实参的“别名”，对形参的操作其实就是对实参的操作，在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。
void swap(int &a, int &b)  {    int temp;  temp=a;  a=b;  b=temp;    }

值传递不如地址传递高效，因为值传递先从实参的地址中取出值，再赋值给形参代入函数计算；而指针则把形参的地址直接指向实参地址，使用时直接取出数据，效率提高，特别在频繁赋值等情况下


10、static、const、volatile关键字的作用及应用范围
修饰函数的局部变量      特点：有默认值0，只执行一次，运行一开始就开辟了内存，内存放在全局
修饰全局函数和全局变量      特点：只能在本源文件使用
修饰类里面的成员变量      不进入类的大小计算，不依赖于类对象的存在而存在（可直接调用，要进行外置声明）
修饰类的成员函数      f():括号里无this指针，只能调用他的本类静态函数和他的静态变量，即是用static修饰过的不依赖于类对象的存在而存在（可不进行外置声明，直接调用）

const 在C++中是用来修饰内置类型变量，自定义对象，成员函数，返回值，函数参数。
const修饰普通类型的变量： const int  a = 7; a被定义为一个常量，并且可以将a赋值给b，但是不能给a再次赋值。
const 修饰指针变量：A:const 修饰指针指向的内容，则内容为不可变量。  B:const 修饰指针，则指针为不可变量。  C:const 修饰指针和指针指向的内容，则指针和指针指向的内容都为不可变量。  （左定值，右定向，const修饰不变量。）
const in function参数传递：A：值传递的const修饰传递，一般这种情况不需要const修饰，因为函数会自动产生临时变量复制实参值。B：当const参数为指针时，可以防止指针被意外篡改。C：自定义类型的参数传递，需要临时对象复制参数，对于临时对象的构造，需要调用构造函数，比较浪费时间，因此我们采取const外加引用传递的方法。
const修饰函数的返回值：const 修饰自定义类型的作为返回值，此时返回的值不能作为左值使用，既不能被赋值，也不能被修改。
const修饰类成员函数：const 修饰类成员函数，其目的是防止成员函数修改被调用对象的值，如果我们不想修改一个调用对象的值，所有的成员函数都应当声明为const成员函数。注意：const关键字不能与static关键字同时使用，因为static关键字修饰静态成员函数，静态成员函数不含有this指针，即不能实例化，const成员函数必须具体到某一实例。尽量按照要求将所有的不需要改变对象内容的函数都作为const成员函数。如果有个成员函数想修改对象中的某一个成员怎么办？这时我们可以使用mutable关键字修饰这个成员，mutable的意思也是易变的，容易改变的意思，被mutable关键字修饰的成员可以处于不断变化中。

volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。
遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问

11、声明和定义
为变量分配地址和存储空间的称为定义，不分配地址的称为声明。一个变量可以在多个地方声明，
但是只在一个地方定义。加入extern修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。说明：很多时候一个变量，只是声明不分配内存空间，直到具体使用时才初始化，分配内存空间，如外部变量。


12、sizeof 和 strlen 的区别
sizeof 是一个操作符，strlen 是库函数
sizeof 的参数可以是数据的类型，也可以是变量，而 strlen 只能以结尾为‘\0‘的字符串作参数。
并且 sizeof 计算的是数据类型占内存的大小，而 strlen 计算的是字符串实际的长度。
编译器在编译时就计算出了 sizeof 的结果。而 strlen 函数必须在运行时才能计算出来。


13、常量指针、指针常量
常量指针：指向常量的指针，指针指向的是常量，即它不能指向变量，它指向的内容不能被改变，不能通过指针来修改它指向的内容，但是指针自身不是常量，它自身的值可以改变，从而可以指向另一个常量。
指针常量：指针本身是常量。它指向的地址是不可改变的，但地址里的内容可以通过指针改变。它指向的地址将伴其一生，直到生命周期结束。有一点需要注意的是，指针常量在定义时必须同时赋初值。
常量指针使用：如 int b, c;  int const *a;
a = &b;  a = &c;  都可以，唯独它指向的内容不能被修改。如：*a=20;这是违法的！错误！

指针常量使用：如 int a ,b;  int * const p = &a;  表示p是一个常量指针它指向变量a的内存。指针常量不能再用p指向其他变量，如 p = &b; 错误！可以修改指向内存的值，如:* p = 20; 指针常量声明的时候必须像上式那样赋初值。
指针常量也不能释放,用p指向NULL，即 p = NULL; 会在编译时报错。

看const关键字，他后面的不可修改，如int * const a = &b; 后面是a,则说明a不能修改！
常量指针：int const *n; 等价于 const int *n;


14、c++四种强制类型转化
static_cast、const_cast、reinterpret_cast和dynamic_cast         新类型的强制转换可以提供更好的控制强制转换过程。
static_cast用于将一种数据类型强制转换为另一种数据类型。
（1）用于类层次结构中基类和派生类之间指针或引用的转换
      进行上行转换（把派生类的指针或引用转换成基类表示）是安全的。进行下行转换（把基类的指针或引用转换为派生类表示），由于没有动态类型检查，所以是不安全的
（2）用于基本数据类型之间的转换，如把int转换成char。这种转换的安全也要开发人员来保证
（3）把空指针转换成目标类型的空指针
（4）把任何类型的表达式转换为void类型
注意：static_cast不能转换掉expression的const、volitale或者__unaligned属性。

const_cast用于强制去掉不能被修改的常数特性，但需要特别注意的是const_cast不是用于去除变量的常量性，而是去除指向常数对象的指针或引用的常量性，其去除常量性的对象必须为指针或引用。
该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。
    常量指针被转化成非常量指针，并且仍然指向原来的对象；
    常量引用被转换成非常量引用，并且仍然指向原来的对象；
    常量对象被转换成非常量对象。

在C++语言中，reinterpret_cast主要有三种强制转换用途：改变指针或引用的类型、将指针或引用转换为一个足够长度的整形、将整型转换为指针或引用类型。
用法：reinterpret_cast<type_id> (expression)    type-id必须是一个指针、引用、算术类型、函数指针或者成员指针。
它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）。在使用reinterpret_cast强制转换过程仅仅只是比特位的拷贝，因此在使用过程中需要特别谨慎！

dynamic_cast<type_id> (expression)
（1）其他三种都是编译时完成的，dynamic_cast是运行时处理的，运行时要进行类型检查。
（2）不能用于内置的基本数据类型的强制转换。
（3）dynamic_cast转换如果成功的话返回的是指向类的指针或引用，转换失败的话则会返回NULL。
（4）使用dynamic_cast进行转换的，基类中一定要有虚函数，否则编译不通过。基类中需要检测有虚函数的原因：类中存在虚函数，就说明它有想要让基类指针或引用指向派生类对象的情况，此时转换才有意义。这是由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表中，只有定义了虚函数的类才有虚函数表。
（5）在类的转换时，在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的。在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。向上转换，即为子类指针指向父类指针（一般不会出问题）；向下转换，即将父类指针转化子类指针。向下转换的成功与否还与将要转换的类型有关，即要转换的指针指向的对象的实际类型与转换以后的对象类型一定要相同，否则转换失败。在C++中，编译期的类型转换有可能会在运行时出现错误，特别是涉及到类对象的指针或引用操作时，更容易产生错误。Dynamic_cast操作符则可以在运行期对可能产生问题的类型转换进行测试。


15、c++ 八种基本数据类型
整型：
byte：-2^7 ~ 2^7-1，即-128 ~ 127。1字节。末尾加B
short：-2^15 ~ 2^15-1，即-32768 ~ 32767。2字节。末尾加S
有符号int：-2^31 ~ 2^31-1，即-2147483648 ~ 2147483647。4字节。
无符号int：0~2^32-1。
long：-2^63 ~ 2^63-1，即-9223372036854774808 ~ 9223372036854774807。4字节。末尾加L。（也可以不加L）
浮点型：
float：4字节。末尾加F。（也可以不加F）
double：8字节。
字符型：
char：1字节。
布尔型：
boolean：1字节。boolean类型与其他基本类型不能进行类型的转换(既不能进行自动类型的提升，也不能强制类型转换)，否则将编译出错。

两个数值进行二元操作时，会有如下的转换操作：如果两个操作数其中有一个是double类型，另一个操作就会转换为double类型。如果其中一个操作数是float类型，另一个将会转换为float类型。如果其中一个操作数是long类型，另一个会转换为long类型。否则，两个操作数都转换为int类型。
当对小于int的数据类型（byte, char, short）进行运算时，首先会把这些类型的变量值强制转为int类型进行计算，最后会得到int类型的值。因此，如果把2个short类型的值相加，最后得到的结果是int类型，如果需要得到short类型的结果，就必须显示地运算结果转为short类型。


15、类class与结构体struct   结构体struct跟联合体union
类中定义的继承和成员变量、成员函数默认都是private属性的，结构体中定义的继承和成员变量、成员函数默认都是public属性的。

struct各成员各自拥有自己的内存，各自使用互不干涉，同时存在的，遵循内存对齐原则。一个struct变量的总长度等于所有成员的长度之和。
union各成员共用一块内存空间，并且同时只有一个成员可以得到这块内存的使用权(对该内存的读写)，各变量共用一个内存首地址。因而，联合体比结构体更节约内存。一个union变量的总长度至少能容纳最大的成员变量，而且要满足是所有成员变量类型大小的整数倍。
对于Union的不同成员赋值，将会对其他成员重写，原来成员的值就不存在了
还有关于struct内存存放顺序的问题以及两者内存对齐方式不同的见下面详解


16、内联函数   使用场景
不是在调用时发生控制转移，而是在编译时将函数体嵌入在每一个调用处，适用于功能简单，规模较小又使用频繁的函数。递归函数无法内联处理，内联函数不能有循环体，switch语句，不能进行异常接口声明。
内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。

内联函数和宏的区别在于，宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的。而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。你可以象调用函数一样来调用内联函数，而不必担心会产生于处理宏的一些问题。内联函数与带参数的宏定义进行下比较，它们的代码效率是一样，但是内联欢函数要优于宏定义，因为内联函数遵循的类型和作用域规则，它与一般函数更相近，在一些编译器中，一旦关联上内联扩展，将与一般函数一样进行调用，比较方便。 
另外，宏定义在使用时只是简单的文本替换，并没有做严格的参数检查，也就不能享受C++编译器严格类型检查的好处，一些在宏中的编译错误很难发现，另外它的返回值也不能被强制转换为可转换的合适的类型，这样，它的使用就存在着一系列的隐患和局限性。
内联函数不能包括复杂的控制语句，如循环语句和switch语句；
内联函数不能包括复杂的控制语句，如循环语句和switch语句；
只将规模很小（一般5个语句一下）而使用频繁的函数声明为内联函数。在函数规模很小的情况下，函数调用的时间开销可能相当于甚至超过执行函数本身的时间，把它定义为内联函数，可大大减少程序运行时间。


17、Linux /proc/$pid部分内容详解
proc/[pid]/cmdline是一个只读文件，包含进程的完整命令行信息。如果这个进程是zombie进程，则这个文件没有任何内容。
/proc/[pid]/comm包含进程的命令名。
/proc/[pid]/environ显示进程的环境变量。
/proc/[pid]/fd是一个目录，包含进程打开文件的情况。
/proc/[pid]/latency显示哪些代码造成的延时比较大。
/proc/[pid]/maps显示进程的内存区域映射信息。


18、指针函数、函数指针
最简单的辨别方式就是看函数名前面的指针*号有没有被括号（）包含，如果被包含就是函数指针，反之则是指针函数。

指针函数是指返回值为指针的函数，即本质是一个函数。
类型标识符 *函数名(参数表)   int *f(x，y);

函数指针是指向函数的指针变量，即本质是一个指针变量。指向函数的指针包含了函数的地址的入口地址，可以通过它来调用函数。
类型说明符 (*函数名)   (参数)    void (*fptr)();
把函数的地址赋值给函数指针，可以采用下面两种形式：fptr=&Function; 或者 fptr=Function;
取地址运算符&不是必需的，因为单单一个函数标识符就标号表示了它的地址，如果是函数调用，还必须包含一个圆括号括起来的参数表。
可以采用如下两种方式来通过指针调用函数：x=(*fptr)(); 或者 x=fptr();


19、大端、小端    网络序、字节序
大小端是面向多字节类型定义的，比如2字节、4字节、8字节整型、长整型、浮点型等，单字节的字符串一般不用考虑。大端小端存储、传输、以及接收处理需要对应。网络字节序一般是指大端传输。
大端：就是高字节在前，内存存储体现上，数据的高位更加靠近低地址。（低地址存高字节）
小端：就是低字节在前，内存存储体现上，数据的低位更加靠近低地址。（低地址存低字节）
htonl()--"Host to Network Long"
ntohl()--"Network to Host Long"
htons()--"Host to Network Short"
ntohs()--"Network to Host Short" 

主机序有大端小端，网络序用大端。

假设一个32位 unsigned int型数据0x12 34 56 78，大小端8位存储方式如下：
大端存储方式为0x12 34 56 78
小端存储方式为0x78 56 34 12


20、基于对象和面向对象的区别
通常“基于对象”是使用对象，但是无法利用现有的对象模板产生新的对象类型，继而产生新的对象，也就是说“基于对象”没有继承的特点。而“多态”表示为父类类型的子类对象实例，没有了继承的概念也就无从谈论“多态”。现在的很多流行技术都是基于对象的，它们使用一些封装好的对象，调用对象的方法，设置对象的属性。但是它们无法让程序员派生新对象类型。他们只能使用现有对象的方法和属性。
“面向对象”和“基于对象”都实现了“封装”的概念，但是面向对象实现了“继承和多态”。简单地说:基于对象不能继承,更谈不上多态。


21、进程和线程的区别与联系？进程间通信方式？
进程（Process） 是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。 在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。
线程（thread） 是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。

a）进程是资源分配的最小单位，线程是程序执行的最小单位（资源调度的最小单位）。
b）进程有自己的独立的地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程小很多，同时创建一个线程的开销也远比进程要小很多。
c）线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式(IPC)进行。
d）但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另一个进程造成影响，因为进程有自己独立的地址空间。

进程间通讯方式：管道、消息队列、信号量、共享内存区、套接字
管道：速度慢，容量有限，只有父子进程能通讯
消息队列：容易受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题
信号量：不能传递复杂消息，只能用来同步
共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存
套接字：可用于不同机器间的进程通信


22、tcp、udp区别联系   （tcp三次握手细节及原因   四次**）    分别列举应用场景？      分别编程步骤？
a、TCP面向连接(如打电话要先拨号建立连接)；UDP是无连接的，即发送数据之前不需要建立连接。
b、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。TCP通过校验和checksum，重传控制，序号标识，滑动窗口机制、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。（UDP程序结构较简单 导致 TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证）
c、UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。
d、每一条TCP连接只能是点到点的；UDP支持一对一、一对多、多对一和多对多的交互通信。
e、TCP对系统资源要求较多，UDP对系统资源要求较少。
f、流模式与数据报模式 ：TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的。
g、TCP首部开销20字节;UDP的首部开销小，只有8个字节。
h、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。

三次握手                       SYN：同步序列编号（Synchronize Sequence Numbers）。
第一次握手：建立连接时，客户端发送syn包（seq=j）到服务器，并进入SYN_SENT状态，等待服务器确认；
第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（seq=k），即SYN+ACK包，此时服务器进入SYN_RECV状态。
第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。


网速的提升给UDP的稳定性提供可靠网络保障，丢包率很低，如果使用应用层重传，能够确保传输的可靠性。
TCP为了实现网络通信的可靠性，使用了复杂的拥塞控制算法，建立了繁琐的握手过程，由于TCP内置的系统协议栈中，极难对其进行改进。


23、#include < >和#include“ ”的区别
a、引用的头文件不同：前者引用的是编译器的类库路径里面的头文件；后者引用的是你程序目录的相对路径中的头文件。
b、用法不同：前者用来包含标准头文件；后者用来包含非标准头文件。
c、调用文件的顺序不同：前者编译程序会先到标准函数库中调用文件；后者编译程序会先从当前目录中调用文件。
d、预处理程序的指示不同：前者指示预处理程序到预定义的缺省路径下寻找文件。后者指示预处理程序先到当前目录下寻找文件，再到预定义的缺省路径下寻找文件。  


24、


25、


26、

















41、设计模式    常用的
工厂模式、策略模式、适配器模式、单例模式、原型模式、模板模式、建造者模式、外观模式、组合模式、代理模式、享元模式、桥接模式、装饰模式、备忘录模式、中介者模式、职责链模式、观察者模式



42、g++ 常用编译选项   编译优化等
-E：只进行预处理（宏展开），不编译
-S：只编译，不汇编
-c：只编译、汇编，不链接
-g：包含调试信息，为了gdb 调试用（开了-g，编译时会创建符号表，关闭所有的优化机制）
-o：输出指定文件名


gcc提供了近大量优化选项，用来对编译时间，目标文件长度，执行效率三个维度进行不同的取舍和平衡。
参考：https://blog.csdn.net/wuxing26jiayou/article/details/96132721?utm_medium=distribute.pc_relevant_bbs_down.none-task--2~all~first_rank_v2~rank_v29-3.nonecase&depth_1-utm_source=distribute.pc_relevant_bbs_down.none-task--2~all~first_rank_v2~rank_v29-3.nonecase
https://blog.csdn.net/lee244868149/article/details/38754153?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-7&spm=1001.2101.3001.4242
优化：（编译器可以检测很多问题，需要慢慢学习）
-O0 不进行优化处理。 
-O 或 -O1 优化生成代码。 
-O2 进一步优化。 
-O3 比 -O2 更进一步优化，包括 inline 函数。（4.x一般不建议使用，可能执行效率变化不大但编译时间过长文件长度增加）




-Wall：会打开一些很有用的警告选项，建议编译时加此选项。具体如下：
	-Waddress  -Warray-bounds (only with -O2)   -Wc++0x-compat  -Wchar-subscripts  -Wimplicit-int
	-Wimplicit-function-declaration  -Wcomment -Wformat -Wmain (only for C/ObjC and unless -ffreestanding)
	-Wmissing-braces -Wnonnull -Wparentheses  -Wpointer-sign -Wreorder -Wreturn-type  -Wsequence-point 
	-Wsign-compare (only in C++) -Wstrict-aliasing -Wstrict-overflow=1  -Wswitch -Wtrigraphs
	-Wuninitialized (only with -O1 and above)  -Wunknown-pragmas -Wunused-function
	-Wunused-label -Wunused-value  -Wunused-variable 
-Wextra：打印一些额外的警告信息（对所有合法但值得怀疑的表达式发出警告）
-W 开启所有 gcc 能提供的警告
-w：禁止显示所有警告信息。
-Wshadow：当一个局部变量遮盖住了另一个局部变量，或者全局变量时，给出警告。建议打开。 -Wall 并不会打开此项。
-Wpointer-arith：对函数指针或者void *类型的指针进行算术操作时给出警告。也很有用。 -Wall 并不会打开此项。
-Wcast-qual：当强制转化丢掉了类型修饰符时给出警告。 -Wall 并不会打开此项。
-Wcast-align：一旦某个指针类型强制转换导致目标所需的地址对齐增加时，编译器就发出警告。
-Wundef：当一个没有定义的符号出现在 #if 中时，给出警告。
-Wunreachable-code：如果编译器探测到永远不会执行到的代码，就给出警告。也是比较有用的选项。
-Wunused-but-set-variable：表示一个变量定义了，但是该变量没有被实际应用到。

需要屏蔽时使用-Wno-xxxxxx，如需屏蔽-Wunused-but-set-variable 这一类警告，可以这样添加编译选项：-Wno-unused-but-set-variable


-Werror：把警告当作错误。出现任何警告就放弃编译。
需要指定具体一类时使用-Werror=xxxxxx，如需将没有返回值当error时使用：-Werror=return-type




42、程序运行得比较慢，有什么优化方案
a）编码技巧，汇编，编译器等也是一方面，但是首先要逻辑优化
b）在问如何提高运行速度前 你应该先去了解你的程序慢在哪儿。现成的工具有很多
    比如可以通过火焰图快速的定位程序到底慢在哪里 然后对症下药。
    了解自己的代码做了什么东西，建议用辅助调试工具来检测profile，可以关注下是否有冗余的计算，I/O，锁
c）了解对应的执行环境，硬件差异，系统差异，比如说CPU的特殊指令，GPU与CPU，SSD的写放大，如IOS里面调动态库的执行速度会比同一个静态库的慢些，由于中途多做了一次寻址；SSD上按字节来写可能比按最小块写要慢
d）如果性能相差很多，很可能问题出现在算法上面。就像冒泡排序和快速排序的差距。了解是否有更加合适的算法，一般来说拿空间换时间，或者拿准确度来换时间


https://blog.csdn.net/N1314N/article/details/94652368?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control


、学到了啥？  下一步规划

、C11的特性（智能指针、anto等等）

、内存为什么要对齐？

、gdb的使用：1、显示线程；2、一个函数的输出作为另一个函数的输出；3、崩溃文件...

、项目的并发量级      有没有性能问题 诊断和优化的生产经验    项目的真实调优过程

、熟悉mysql关系型数据库以及redis缓存型数据库

、熟悉nginx、libevent多线程开发

、一些编程小技巧
a、能用引用的地方尽量用引用，这比指针高效，因为引用无需检验
b、
c、


、this指针的作用

、讲一下堆与找的区别与联系（内存分配Heap和stack的区别）
为啥malloc申请到的堆的空间是连续的？   是因为前面有个空间存储了长度？


、加载动态库的几种方式？运行时调用的几种方式？


、七层网络模型、5层网络模型、以及分别对应的协议

、为啥从main开始？

、epoll和select的区别是什么？epoll高效率的原因是什么？（分别适用在什么应用场景）

、野指针   内存泄漏    指针悬挂      （分别是什么？代表什么？怎么造成？怎么避免解决？）
（多个指针指向一块内存，free掉一个指针之后，别的指针就成了野指针？）


、查bug思路

、linux常用命令
    linux怎么看进程下面的线程
    高效地在linux查找：find找文件    grep根据文件内容查找    which查看可执行文件位置    whereis寻找特定文件    locate配合数据库查看文件位置？？
    nm  objdump  readelf

、算法题：

mencpy函数实现
void * my_mencpy(void *dst, const void *src, unsigned count)
{
	if(dst == nullptr || src == nullptr) return nullptr;
	char *pdst = (char*)dst;
	char *psrc = (char*)src;
	while(count--)
	{
		*pdst++ = *psrc++;
	}
	return dst;
}

strcpy函数实现
char *my_strcpy(char* dst, const char* src)
{
	if(dst == nullptr || src == nullptr) return nullptr;
	char* temp = dst;
	while( (*dst++ = *src++) != '\0' ) ;
	return temp;
}

https://blog.csdn.net/qq_42627619/article/details/91046831
冒泡排序、快速排序、二分查找
设计栈  入栈  出栈  找最小元素
设计string  成员
编写简单的回显函数
创建一个单向链表，插入十个数据
创建一个二叉树，插入是个数据
写一个判定任意二进制树height的程序
创建一个检查某个词是否回文的函数
通用二元一次方程函数
图像边缘检测原理
c++的STL中，有哪几种容器？  STL里面vector（数组）、list（双向链表）、map、set数据结构以及底层实现   以及应用场景
查询多，插入少  用什么？为什么？
通信、linux系统编程
socket通信（了解：127.0.0.1::port1能不能与127.0.0.1::port2建链）


逻辑题:
、从一副牌中抽取两张，同一花色地出现概率是多少？



编程实现从 1 加到 100 和从 100 加到 1 两个程序，哪个更快？    参考：https://www.zhihu.com/question/316554171
开编译器优化的情况：编译器直接算出结果5050（测试过是有一定范围的，算1到100000时就是：1加到n比n加到1多一个cmp指令）
不开编译器优化的情况：时操指令数量上没啥差别（并没有出现网上说的，100加到1有出现jnz指令，然后jnz指令要明显快于cmp之后再jne）





以下需要联系运算符优先级学习，比如   int i=1，j=2，求表达式i+++j的值？

整理下  a++，++a  ???      //i++和++i的区别:  i++是先用后加，直接执行i+1然后返回i的引用 ++i是先加后用，先创建i的副本然后i+1，最后返回副本  ???
#include <stdio.h>
#include <iostream>
using namespace std;
#define MU(a) ((a)*(a)*(a))
int main(int argc,char *argv[])
{
	int i = 10;
	/*int Sum = Add(i);
	printf("sUM1 = %d\n",Sum);
	int sum = MU(++i);
	printf("i = %d MU = %d\n",i,sum);*/

	printf("%d %d %d %d\n", ++i,i++,i++,i++);
	i = 10;
	//printf("%p %p %p\n", i++,++i,i);
	printf("%d\n",i);
	printf("%d %d %d %d\n", i,i,i++,i++);
	i = 10;
	printf("%d %d\n", i++,i++);
	i = 10;
	printf("%d %d\n", ++i,++i);
	i = 10;
	cout<<++i<<","<<i++<<endl;
	i = 2;
	printf("%d %d %d \n",i*=2,++i,i++);
	return 0;
}